// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: et_def.proto
// Protobuf C++ Version: 4.25.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_et_5fdef_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_et_5fdef_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_et_5fdef_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_et_5fdef_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_et_5fdef_2eproto;
namespace ChakraProtoMsg {
class AttributeProto;
struct AttributeProtoDefaultTypeInternal;
extern AttributeProtoDefaultTypeInternal _AttributeProto_default_instance_;
class BoolList;
struct BoolListDefaultTypeInternal;
extern BoolListDefaultTypeInternal _BoolList_default_instance_;
class BytesList;
struct BytesListDefaultTypeInternal;
extern BytesListDefaultTypeInternal _BytesList_default_instance_;
class DoubleList;
struct DoubleListDefaultTypeInternal;
extern DoubleListDefaultTypeInternal _DoubleList_default_instance_;
class Fixed32List;
struct Fixed32ListDefaultTypeInternal;
extern Fixed32ListDefaultTypeInternal _Fixed32List_default_instance_;
class Fixed64List;
struct Fixed64ListDefaultTypeInternal;
extern Fixed64ListDefaultTypeInternal _Fixed64List_default_instance_;
class FloatList;
struct FloatListDefaultTypeInternal;
extern FloatListDefaultTypeInternal _FloatList_default_instance_;
class GlobalMetadata;
struct GlobalMetadataDefaultTypeInternal;
extern GlobalMetadataDefaultTypeInternal _GlobalMetadata_default_instance_;
class IOInfo;
struct IOInfoDefaultTypeInternal;
extern IOInfoDefaultTypeInternal _IOInfo_default_instance_;
class Int32List;
struct Int32ListDefaultTypeInternal;
extern Int32ListDefaultTypeInternal _Int32List_default_instance_;
class Int64List;
struct Int64ListDefaultTypeInternal;
extern Int64ListDefaultTypeInternal _Int64List_default_instance_;
class Node;
struct NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
class Sfixed32List;
struct Sfixed32ListDefaultTypeInternal;
extern Sfixed32ListDefaultTypeInternal _Sfixed32List_default_instance_;
class Sfixed64List;
struct Sfixed64ListDefaultTypeInternal;
extern Sfixed64ListDefaultTypeInternal _Sfixed64List_default_instance_;
class Sint32List;
struct Sint32ListDefaultTypeInternal;
extern Sint32ListDefaultTypeInternal _Sint32List_default_instance_;
class Sint64List;
struct Sint64ListDefaultTypeInternal;
extern Sint64ListDefaultTypeInternal _Sint64List_default_instance_;
class StringList;
struct StringListDefaultTypeInternal;
extern StringListDefaultTypeInternal _StringList_default_instance_;
class Tensor;
struct TensorDefaultTypeInternal;
extern TensorDefaultTypeInternal _Tensor_default_instance_;
class Uint32List;
struct Uint32ListDefaultTypeInternal;
extern Uint32ListDefaultTypeInternal _Uint32List_default_instance_;
class Uint64List;
struct Uint64ListDefaultTypeInternal;
extern Uint64ListDefaultTypeInternal _Uint64List_default_instance_;
}  // namespace ChakraProtoMsg
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace ChakraProtoMsg {
enum NodeType : int {
  INVALID_NODE = 0,
  METADATA_NODE = 1,
  MEM_LOAD_NODE = 2,
  MEM_STORE_NODE = 3,
  COMP_NODE = 4,
  COMM_SEND_NODE = 5,
  COMM_RECV_NODE = 6,
  COMM_COLL_NODE = 7,
  NodeType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  NodeType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool NodeType_IsValid(int value);
extern const uint32_t NodeType_internal_data_[];
constexpr NodeType NodeType_MIN = static_cast<NodeType>(0);
constexpr NodeType NodeType_MAX = static_cast<NodeType>(7);
constexpr int NodeType_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
NodeType_descriptor();
template <typename T>
const std::string& NodeType_Name(T value) {
  static_assert(std::is_same<T, NodeType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to NodeType_Name().");
  return NodeType_Name(static_cast<NodeType>(value));
}
template <>
inline const std::string& NodeType_Name(NodeType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NodeType_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool NodeType_Parse(absl::string_view name, NodeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeType>(
      NodeType_descriptor(), name, value);
}
enum CollectiveCommType : int {
  ALL_REDUCE = 0,
  REDUCE = 1,
  ALL_GATHER = 2,
  GATHER = 3,
  SCATTER = 4,
  BROADCAST = 5,
  ALL_TO_ALL = 6,
  REDUCE_SCATTER = 7,
  REDUCE_SCATTER_BLOCK = 8,
  BARRIER = 9,
  CollectiveCommType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CollectiveCommType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CollectiveCommType_IsValid(int value);
extern const uint32_t CollectiveCommType_internal_data_[];
constexpr CollectiveCommType CollectiveCommType_MIN = static_cast<CollectiveCommType>(0);
constexpr CollectiveCommType CollectiveCommType_MAX = static_cast<CollectiveCommType>(9);
constexpr int CollectiveCommType_ARRAYSIZE = 9 + 1;
const ::google::protobuf::EnumDescriptor*
CollectiveCommType_descriptor();
template <typename T>
const std::string& CollectiveCommType_Name(T value) {
  static_assert(std::is_same<T, CollectiveCommType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CollectiveCommType_Name().");
  return CollectiveCommType_Name(static_cast<CollectiveCommType>(value));
}
template <>
inline const std::string& CollectiveCommType_Name(CollectiveCommType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CollectiveCommType_descriptor,
                                                 0, 9>(
      static_cast<int>(value));
}
inline bool CollectiveCommType_Parse(absl::string_view name, CollectiveCommType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CollectiveCommType>(
      CollectiveCommType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Uint64List final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Uint64List) */ {
 public:
  inline Uint64List() : Uint64List(nullptr) {}
  ~Uint64List() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Uint64List(::google::protobuf::internal::ConstantInitialized);

  inline Uint64List(const Uint64List& from)
      : Uint64List(nullptr, from) {}
  Uint64List(Uint64List&& from) noexcept
    : Uint64List() {
    *this = ::std::move(from);
  }

  inline Uint64List& operator=(const Uint64List& from) {
    CopyFrom(from);
    return *this;
  }
  inline Uint64List& operator=(Uint64List&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Uint64List& default_instance() {
    return *internal_default_instance();
  }
  static inline const Uint64List* internal_default_instance() {
    return reinterpret_cast<const Uint64List*>(
               &_Uint64List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Uint64List& a, Uint64List& b) {
    a.Swap(&b);
  }
  inline void Swap(Uint64List* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Uint64List* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Uint64List* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Uint64List>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Uint64List& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Uint64List& from) {
    Uint64List::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Uint64List* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ChakraProtoMsg.Uint64List";
  }
  protected:
  explicit Uint64List(::google::protobuf::Arena* arena);
  Uint64List(::google::protobuf::Arena* arena, const Uint64List& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated uint64 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  ::uint64_t values(int index) const;
  void set_values(int index, ::uint64_t value);
  void add_values(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& values() const;
  ::google::protobuf::RepeatedField<::uint64_t>* mutable_values();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_values() const;
  ::google::protobuf::RepeatedField<::uint64_t>* _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Uint64List)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<::uint64_t> values_;
    mutable ::google::protobuf::internal::CachedSize _values_cached_byte_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};// -------------------------------------------------------------------

class Uint32List final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Uint32List) */ {
 public:
  inline Uint32List() : Uint32List(nullptr) {}
  ~Uint32List() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Uint32List(::google::protobuf::internal::ConstantInitialized);

  inline Uint32List(const Uint32List& from)
      : Uint32List(nullptr, from) {}
  Uint32List(Uint32List&& from) noexcept
    : Uint32List() {
    *this = ::std::move(from);
  }

  inline Uint32List& operator=(const Uint32List& from) {
    CopyFrom(from);
    return *this;
  }
  inline Uint32List& operator=(Uint32List&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Uint32List& default_instance() {
    return *internal_default_instance();
  }
  static inline const Uint32List* internal_default_instance() {
    return reinterpret_cast<const Uint32List*>(
               &_Uint32List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Uint32List& a, Uint32List& b) {
    a.Swap(&b);
  }
  inline void Swap(Uint32List* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Uint32List* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Uint32List* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Uint32List>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Uint32List& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Uint32List& from) {
    Uint32List::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Uint32List* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ChakraProtoMsg.Uint32List";
  }
  protected:
  explicit Uint32List(::google::protobuf::Arena* arena);
  Uint32List(::google::protobuf::Arena* arena, const Uint32List& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated uint32 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  ::uint32_t values(int index) const;
  void set_values(int index, ::uint32_t value);
  void add_values(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& values() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_values();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_values() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Uint32List)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<::uint32_t> values_;
    mutable ::google::protobuf::internal::CachedSize _values_cached_byte_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};// -------------------------------------------------------------------

class Tensor final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Tensor) */ {
 public:
  inline Tensor() : Tensor(nullptr) {}
  ~Tensor() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Tensor(::google::protobuf::internal::ConstantInitialized);

  inline Tensor(const Tensor& from)
      : Tensor(nullptr, from) {}
  Tensor(Tensor&& from) noexcept
    : Tensor() {
    *this = ::std::move(from);
  }

  inline Tensor& operator=(const Tensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tensor& operator=(Tensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tensor* internal_default_instance() {
    return reinterpret_cast<const Tensor*>(
               &_Tensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Tensor& a, Tensor& b) {
    a.Swap(&b);
  }
  inline void Swap(Tensor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tensor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tensor* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tensor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Tensor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Tensor& from) {
    Tensor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Tensor* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ChakraProtoMsg.Tensor";
  }
  protected:
  explicit Tensor(::google::protobuf::Arena* arena);
  Tensor(::google::protobuf::Arena* arena, const Tensor& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 6,
    kTensorIdFieldNumber = 1,
    kStorageIdFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kNumElemFieldNumber = 4,
    kElemBytesFieldNumber = 5,
  };
  // string device = 6;
  void clear_device() ;
  const std::string& device() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device(Arg_&& arg, Args_... args);
  std::string* mutable_device();
  PROTOBUF_NODISCARD std::string* release_device();
  void set_allocated_device(std::string* value);

  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(
      const std::string& value);
  std::string* _internal_mutable_device();

  public:
  // uint64 tensor_id = 1;
  void clear_tensor_id() ;
  ::uint64_t tensor_id() const;
  void set_tensor_id(::uint64_t value);

  private:
  ::uint64_t _internal_tensor_id() const;
  void _internal_set_tensor_id(::uint64_t value);

  public:
  // uint64 storage_id = 2;
  void clear_storage_id() ;
  ::uint64_t storage_id() const;
  void set_storage_id(::uint64_t value);

  private:
  ::uint64_t _internal_storage_id() const;
  void _internal_set_storage_id(::uint64_t value);

  public:
  // uint64 offset = 3;
  void clear_offset() ;
  ::uint64_t offset() const;
  void set_offset(::uint64_t value);

  private:
  ::uint64_t _internal_offset() const;
  void _internal_set_offset(::uint64_t value);

  public:
  // uint64 num_elem = 4;
  void clear_num_elem() ;
  ::uint64_t num_elem() const;
  void set_num_elem(::uint64_t value);

  private:
  ::uint64_t _internal_num_elem() const;
  void _internal_set_num_elem(::uint64_t value);

  public:
  // uint64 elem_bytes = 5;
  void clear_elem_bytes() ;
  ::uint64_t elem_bytes() const;
  void set_elem_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_elem_bytes() const;
  void _internal_set_elem_bytes(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Tensor)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      36, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr device_;
    ::uint64_t tensor_id_;
    ::uint64_t storage_id_;
    ::uint64_t offset_;
    ::uint64_t num_elem_;
    ::uint64_t elem_bytes_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};// -------------------------------------------------------------------

class StringList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.StringList) */ {
 public:
  inline StringList() : StringList(nullptr) {}
  ~StringList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StringList(::google::protobuf::internal::ConstantInitialized);

  inline StringList(const StringList& from)
      : StringList(nullptr, from) {}
  StringList(StringList&& from) noexcept
    : StringList() {
    *this = ::std::move(from);
  }

  inline StringList& operator=(const StringList& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringList& operator=(StringList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StringList& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringList* internal_default_instance() {
    return reinterpret_cast<const StringList*>(
               &_StringList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(StringList& a, StringList& b) {
    a.Swap(&b);
  }
  inline void Swap(StringList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StringList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StringList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StringList& from) {
    StringList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StringList* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ChakraProtoMsg.StringList";
  }
  protected:
  explicit StringList(::google::protobuf::Arena* arena);
  StringList(::google::protobuf::Arena* arena, const StringList& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated string values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  const std::string& values(int index) const;
  std::string* mutable_values(int index);
  void set_values(int index, const std::string& value);
  void set_values(int index, std::string&& value);
  void set_values(int index, const char* value);
  void set_values(int index, const char* value, std::size_t size);
  void set_values(int index, absl::string_view value);
  std::string* add_values();
  void add_values(const std::string& value);
  void add_values(std::string&& value);
  void add_values(const char* value);
  void add_values(const char* value, std::size_t size);
  void add_values(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& values() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_values();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_values() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.StringList)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      40, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> values_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};// -------------------------------------------------------------------

class Sint64List final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Sint64List) */ {
 public:
  inline Sint64List() : Sint64List(nullptr) {}
  ~Sint64List() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Sint64List(::google::protobuf::internal::ConstantInitialized);

  inline Sint64List(const Sint64List& from)
      : Sint64List(nullptr, from) {}
  Sint64List(Sint64List&& from) noexcept
    : Sint64List() {
    *this = ::std::move(from);
  }

  inline Sint64List& operator=(const Sint64List& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sint64List& operator=(Sint64List&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sint64List& default_instance() {
    return *internal_default_instance();
  }
  static inline const Sint64List* internal_default_instance() {
    return reinterpret_cast<const Sint64List*>(
               &_Sint64List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Sint64List& a, Sint64List& b) {
    a.Swap(&b);
  }
  inline void Swap(Sint64List* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sint64List* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Sint64List* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Sint64List>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Sint64List& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Sint64List& from) {
    Sint64List::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Sint64List* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ChakraProtoMsg.Sint64List";
  }
  protected:
  explicit Sint64List(::google::protobuf::Arena* arena);
  Sint64List(::google::protobuf::Arena* arena, const Sint64List& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated sint64 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  ::int64_t values(int index) const;
  void set_values(int index, ::int64_t value);
  void add_values(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& values() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_values();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_values() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Sint64List)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<::int64_t> values_;
    mutable ::google::protobuf::internal::CachedSize _values_cached_byte_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};// -------------------------------------------------------------------

class Sint32List final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Sint32List) */ {
 public:
  inline Sint32List() : Sint32List(nullptr) {}
  ~Sint32List() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Sint32List(::google::protobuf::internal::ConstantInitialized);

  inline Sint32List(const Sint32List& from)
      : Sint32List(nullptr, from) {}
  Sint32List(Sint32List&& from) noexcept
    : Sint32List() {
    *this = ::std::move(from);
  }

  inline Sint32List& operator=(const Sint32List& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sint32List& operator=(Sint32List&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sint32List& default_instance() {
    return *internal_default_instance();
  }
  static inline const Sint32List* internal_default_instance() {
    return reinterpret_cast<const Sint32List*>(
               &_Sint32List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Sint32List& a, Sint32List& b) {
    a.Swap(&b);
  }
  inline void Swap(Sint32List* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sint32List* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Sint32List* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Sint32List>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Sint32List& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Sint32List& from) {
    Sint32List::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Sint32List* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ChakraProtoMsg.Sint32List";
  }
  protected:
  explicit Sint32List(::google::protobuf::Arena* arena);
  Sint32List(::google::protobuf::Arena* arena, const Sint32List& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated sint32 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  ::int32_t values(int index) const;
  void set_values(int index, ::int32_t value);
  void add_values(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& values() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_values();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_values() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Sint32List)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<::int32_t> values_;
    mutable ::google::protobuf::internal::CachedSize _values_cached_byte_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};// -------------------------------------------------------------------

class Sfixed64List final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Sfixed64List) */ {
 public:
  inline Sfixed64List() : Sfixed64List(nullptr) {}
  ~Sfixed64List() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Sfixed64List(::google::protobuf::internal::ConstantInitialized);

  inline Sfixed64List(const Sfixed64List& from)
      : Sfixed64List(nullptr, from) {}
  Sfixed64List(Sfixed64List&& from) noexcept
    : Sfixed64List() {
    *this = ::std::move(from);
  }

  inline Sfixed64List& operator=(const Sfixed64List& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sfixed64List& operator=(Sfixed64List&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sfixed64List& default_instance() {
    return *internal_default_instance();
  }
  static inline const Sfixed64List* internal_default_instance() {
    return reinterpret_cast<const Sfixed64List*>(
               &_Sfixed64List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Sfixed64List& a, Sfixed64List& b) {
    a.Swap(&b);
  }
  inline void Swap(Sfixed64List* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sfixed64List* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Sfixed64List* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Sfixed64List>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Sfixed64List& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Sfixed64List& from) {
    Sfixed64List::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Sfixed64List* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ChakraProtoMsg.Sfixed64List";
  }
  protected:
  explicit Sfixed64List(::google::protobuf::Arena* arena);
  Sfixed64List(::google::protobuf::Arena* arena, const Sfixed64List& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated sfixed64 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  ::int64_t values(int index) const;
  void set_values(int index, ::int64_t value);
  void add_values(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& values() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_values();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_values() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Sfixed64List)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<::int64_t> values_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};// -------------------------------------------------------------------

class Sfixed32List final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Sfixed32List) */ {
 public:
  inline Sfixed32List() : Sfixed32List(nullptr) {}
  ~Sfixed32List() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Sfixed32List(::google::protobuf::internal::ConstantInitialized);

  inline Sfixed32List(const Sfixed32List& from)
      : Sfixed32List(nullptr, from) {}
  Sfixed32List(Sfixed32List&& from) noexcept
    : Sfixed32List() {
    *this = ::std::move(from);
  }

  inline Sfixed32List& operator=(const Sfixed32List& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sfixed32List& operator=(Sfixed32List&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sfixed32List& default_instance() {
    return *internal_default_instance();
  }
  static inline const Sfixed32List* internal_default_instance() {
    return reinterpret_cast<const Sfixed32List*>(
               &_Sfixed32List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Sfixed32List& a, Sfixed32List& b) {
    a.Swap(&b);
  }
  inline void Swap(Sfixed32List* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sfixed32List* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Sfixed32List* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Sfixed32List>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Sfixed32List& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Sfixed32List& from) {
    Sfixed32List::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Sfixed32List* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ChakraProtoMsg.Sfixed32List";
  }
  protected:
  explicit Sfixed32List(::google::protobuf::Arena* arena);
  Sfixed32List(::google::protobuf::Arena* arena, const Sfixed32List& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated sfixed32 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  ::int32_t values(int index) const;
  void set_values(int index, ::int32_t value);
  void add_values(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& values() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_values();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_values() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Sfixed32List)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<::int32_t> values_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};// -------------------------------------------------------------------

class Int64List final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Int64List) */ {
 public:
  inline Int64List() : Int64List(nullptr) {}
  ~Int64List() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Int64List(::google::protobuf::internal::ConstantInitialized);

  inline Int64List(const Int64List& from)
      : Int64List(nullptr, from) {}
  Int64List(Int64List&& from) noexcept
    : Int64List() {
    *this = ::std::move(from);
  }

  inline Int64List& operator=(const Int64List& from) {
    CopyFrom(from);
    return *this;
  }
  inline Int64List& operator=(Int64List&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Int64List& default_instance() {
    return *internal_default_instance();
  }
  static inline const Int64List* internal_default_instance() {
    return reinterpret_cast<const Int64List*>(
               &_Int64List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Int64List& a, Int64List& b) {
    a.Swap(&b);
  }
  inline void Swap(Int64List* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Int64List* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Int64List* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Int64List>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Int64List& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Int64List& from) {
    Int64List::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Int64List* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ChakraProtoMsg.Int64List";
  }
  protected:
  explicit Int64List(::google::protobuf::Arena* arena);
  Int64List(::google::protobuf::Arena* arena, const Int64List& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated int64 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  ::int64_t values(int index) const;
  void set_values(int index, ::int64_t value);
  void add_values(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& values() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_values();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_values() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Int64List)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<::int64_t> values_;
    mutable ::google::protobuf::internal::CachedSize _values_cached_byte_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};// -------------------------------------------------------------------

class Int32List final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Int32List) */ {
 public:
  inline Int32List() : Int32List(nullptr) {}
  ~Int32List() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Int32List(::google::protobuf::internal::ConstantInitialized);

  inline Int32List(const Int32List& from)
      : Int32List(nullptr, from) {}
  Int32List(Int32List&& from) noexcept
    : Int32List() {
    *this = ::std::move(from);
  }

  inline Int32List& operator=(const Int32List& from) {
    CopyFrom(from);
    return *this;
  }
  inline Int32List& operator=(Int32List&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Int32List& default_instance() {
    return *internal_default_instance();
  }
  static inline const Int32List* internal_default_instance() {
    return reinterpret_cast<const Int32List*>(
               &_Int32List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Int32List& a, Int32List& b) {
    a.Swap(&b);
  }
  inline void Swap(Int32List* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Int32List* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Int32List* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Int32List>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Int32List& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Int32List& from) {
    Int32List::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Int32List* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ChakraProtoMsg.Int32List";
  }
  protected:
  explicit Int32List(::google::protobuf::Arena* arena);
  Int32List(::google::protobuf::Arena* arena, const Int32List& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated int32 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  ::int32_t values(int index) const;
  void set_values(int index, ::int32_t value);
  void add_values(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& values() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_values();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_values() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Int32List)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<::int32_t> values_;
    mutable ::google::protobuf::internal::CachedSize _values_cached_byte_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};// -------------------------------------------------------------------

class IOInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.IOInfo) */ {
 public:
  inline IOInfo() : IOInfo(nullptr) {}
  ~IOInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IOInfo(::google::protobuf::internal::ConstantInitialized);

  inline IOInfo(const IOInfo& from)
      : IOInfo(nullptr, from) {}
  IOInfo(IOInfo&& from) noexcept
    : IOInfo() {
    *this = ::std::move(from);
  }

  inline IOInfo& operator=(const IOInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline IOInfo& operator=(IOInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IOInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const IOInfo* internal_default_instance() {
    return reinterpret_cast<const IOInfo*>(
               &_IOInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(IOInfo& a, IOInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(IOInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IOInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IOInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IOInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IOInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const IOInfo& from) {
    IOInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(IOInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ChakraProtoMsg.IOInfo";
  }
  protected:
  explicit IOInfo(::google::protobuf::Arena* arena);
  IOInfo(::google::protobuf::Arena* arena, const IOInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
    kShapesFieldNumber = 2,
    kTypesFieldNumber = 3,
  };
  // string values = 1;
  void clear_values() ;
  const std::string& values() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_values(Arg_&& arg, Args_... args);
  std::string* mutable_values();
  PROTOBUF_NODISCARD std::string* release_values();
  void set_allocated_values(std::string* value);

  private:
  const std::string& _internal_values() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_values(
      const std::string& value);
  std::string* _internal_mutable_values();

  public:
  // string shapes = 2;
  void clear_shapes() ;
  const std::string& shapes() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_shapes(Arg_&& arg, Args_... args);
  std::string* mutable_shapes();
  PROTOBUF_NODISCARD std::string* release_shapes();
  void set_allocated_shapes(std::string* value);

  private:
  const std::string& _internal_shapes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shapes(
      const std::string& value);
  std::string* _internal_mutable_shapes();

  public:
  // string types = 3;
  void clear_types() ;
  const std::string& types() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_types(Arg_&& arg, Args_... args);
  std::string* mutable_types();
  PROTOBUF_NODISCARD std::string* release_types();
  void set_allocated_types(std::string* value);

  private:
  const std::string& _internal_types() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_types(
      const std::string& value);
  std::string* _internal_mutable_types();

  public:
  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.IOInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      47, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr values_;
    ::google::protobuf::internal::ArenaStringPtr shapes_;
    ::google::protobuf::internal::ArenaStringPtr types_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};// -------------------------------------------------------------------

class FloatList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.FloatList) */ {
 public:
  inline FloatList() : FloatList(nullptr) {}
  ~FloatList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FloatList(::google::protobuf::internal::ConstantInitialized);

  inline FloatList(const FloatList& from)
      : FloatList(nullptr, from) {}
  FloatList(FloatList&& from) noexcept
    : FloatList() {
    *this = ::std::move(from);
  }

  inline FloatList& operator=(const FloatList& from) {
    CopyFrom(from);
    return *this;
  }
  inline FloatList& operator=(FloatList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FloatList& default_instance() {
    return *internal_default_instance();
  }
  static inline const FloatList* internal_default_instance() {
    return reinterpret_cast<const FloatList*>(
               &_FloatList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FloatList& a, FloatList& b) {
    a.Swap(&b);
  }
  inline void Swap(FloatList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FloatList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FloatList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FloatList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FloatList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const FloatList& from) {
    FloatList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FloatList* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ChakraProtoMsg.FloatList";
  }
  protected:
  explicit FloatList(::google::protobuf::Arena* arena);
  FloatList(::google::protobuf::Arena* arena, const FloatList& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated float values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  float values(int index) const;
  void set_values(int index, float value);
  void add_values(float value);
  const ::google::protobuf::RepeatedField<float>& values() const;
  ::google::protobuf::RepeatedField<float>* mutable_values();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_values() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.FloatList)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<float> values_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};// -------------------------------------------------------------------

class Fixed64List final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Fixed64List) */ {
 public:
  inline Fixed64List() : Fixed64List(nullptr) {}
  ~Fixed64List() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Fixed64List(::google::protobuf::internal::ConstantInitialized);

  inline Fixed64List(const Fixed64List& from)
      : Fixed64List(nullptr, from) {}
  Fixed64List(Fixed64List&& from) noexcept
    : Fixed64List() {
    *this = ::std::move(from);
  }

  inline Fixed64List& operator=(const Fixed64List& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fixed64List& operator=(Fixed64List&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Fixed64List& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fixed64List* internal_default_instance() {
    return reinterpret_cast<const Fixed64List*>(
               &_Fixed64List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Fixed64List& a, Fixed64List& b) {
    a.Swap(&b);
  }
  inline void Swap(Fixed64List* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fixed64List* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fixed64List* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fixed64List>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Fixed64List& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Fixed64List& from) {
    Fixed64List::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Fixed64List* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ChakraProtoMsg.Fixed64List";
  }
  protected:
  explicit Fixed64List(::google::protobuf::Arena* arena);
  Fixed64List(::google::protobuf::Arena* arena, const Fixed64List& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated fixed64 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  ::uint64_t values(int index) const;
  void set_values(int index, ::uint64_t value);
  void add_values(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& values() const;
  ::google::protobuf::RepeatedField<::uint64_t>* mutable_values();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_values() const;
  ::google::protobuf::RepeatedField<::uint64_t>* _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Fixed64List)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<::uint64_t> values_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};// -------------------------------------------------------------------

class Fixed32List final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Fixed32List) */ {
 public:
  inline Fixed32List() : Fixed32List(nullptr) {}
  ~Fixed32List() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Fixed32List(::google::protobuf::internal::ConstantInitialized);

  inline Fixed32List(const Fixed32List& from)
      : Fixed32List(nullptr, from) {}
  Fixed32List(Fixed32List&& from) noexcept
    : Fixed32List() {
    *this = ::std::move(from);
  }

  inline Fixed32List& operator=(const Fixed32List& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fixed32List& operator=(Fixed32List&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Fixed32List& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fixed32List* internal_default_instance() {
    return reinterpret_cast<const Fixed32List*>(
               &_Fixed32List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Fixed32List& a, Fixed32List& b) {
    a.Swap(&b);
  }
  inline void Swap(Fixed32List* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fixed32List* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fixed32List* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fixed32List>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Fixed32List& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Fixed32List& from) {
    Fixed32List::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Fixed32List* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ChakraProtoMsg.Fixed32List";
  }
  protected:
  explicit Fixed32List(::google::protobuf::Arena* arena);
  Fixed32List(::google::protobuf::Arena* arena, const Fixed32List& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated fixed32 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  ::uint32_t values(int index) const;
  void set_values(int index, ::uint32_t value);
  void add_values(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& values() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_values();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_values() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Fixed32List)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<::uint32_t> values_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};// -------------------------------------------------------------------

class DoubleList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.DoubleList) */ {
 public:
  inline DoubleList() : DoubleList(nullptr) {}
  ~DoubleList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DoubleList(::google::protobuf::internal::ConstantInitialized);

  inline DoubleList(const DoubleList& from)
      : DoubleList(nullptr, from) {}
  DoubleList(DoubleList&& from) noexcept
    : DoubleList() {
    *this = ::std::move(from);
  }

  inline DoubleList& operator=(const DoubleList& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoubleList& operator=(DoubleList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoubleList& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoubleList* internal_default_instance() {
    return reinterpret_cast<const DoubleList*>(
               &_DoubleList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DoubleList& a, DoubleList& b) {
    a.Swap(&b);
  }
  inline void Swap(DoubleList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoubleList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoubleList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoubleList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DoubleList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DoubleList& from) {
    DoubleList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DoubleList* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ChakraProtoMsg.DoubleList";
  }
  protected:
  explicit DoubleList(::google::protobuf::Arena* arena);
  DoubleList(::google::protobuf::Arena* arena, const DoubleList& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated double values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  double values(int index) const;
  void set_values(int index, double value);
  void add_values(double value);
  const ::google::protobuf::RepeatedField<double>& values() const;
  ::google::protobuf::RepeatedField<double>* mutable_values();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_values() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.DoubleList)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<double> values_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};// -------------------------------------------------------------------

class BytesList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.BytesList) */ {
 public:
  inline BytesList() : BytesList(nullptr) {}
  ~BytesList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BytesList(::google::protobuf::internal::ConstantInitialized);

  inline BytesList(const BytesList& from)
      : BytesList(nullptr, from) {}
  BytesList(BytesList&& from) noexcept
    : BytesList() {
    *this = ::std::move(from);
  }

  inline BytesList& operator=(const BytesList& from) {
    CopyFrom(from);
    return *this;
  }
  inline BytesList& operator=(BytesList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BytesList& default_instance() {
    return *internal_default_instance();
  }
  static inline const BytesList* internal_default_instance() {
    return reinterpret_cast<const BytesList*>(
               &_BytesList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(BytesList& a, BytesList& b) {
    a.Swap(&b);
  }
  inline void Swap(BytesList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BytesList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BytesList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BytesList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BytesList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BytesList& from) {
    BytesList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BytesList* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ChakraProtoMsg.BytesList";
  }
  protected:
  explicit BytesList(::google::protobuf::Arena* arena);
  BytesList(::google::protobuf::Arena* arena, const BytesList& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated bytes values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  const std::string& values(int index) const;
  std::string* mutable_values(int index);
  void set_values(int index, const std::string& value);
  void set_values(int index, std::string&& value);
  void set_values(int index, const char* value);
  void set_values(int index, const void* value, std::size_t size);
  void set_values(int index, absl::string_view value);
  std::string* add_values();
  void add_values(const std::string& value);
  void add_values(std::string&& value);
  void add_values(const char* value);
  void add_values(const void* value, std::size_t size);
  void add_values(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& values() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_values();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_values() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.BytesList)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> values_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};// -------------------------------------------------------------------

class BoolList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.BoolList) */ {
 public:
  inline BoolList() : BoolList(nullptr) {}
  ~BoolList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BoolList(::google::protobuf::internal::ConstantInitialized);

  inline BoolList(const BoolList& from)
      : BoolList(nullptr, from) {}
  BoolList(BoolList&& from) noexcept
    : BoolList() {
    *this = ::std::move(from);
  }

  inline BoolList& operator=(const BoolList& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoolList& operator=(BoolList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoolList& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoolList* internal_default_instance() {
    return reinterpret_cast<const BoolList*>(
               &_BoolList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BoolList& a, BoolList& b) {
    a.Swap(&b);
  }
  inline void Swap(BoolList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoolList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoolList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoolList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BoolList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BoolList& from) {
    BoolList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BoolList* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ChakraProtoMsg.BoolList";
  }
  protected:
  explicit BoolList(::google::protobuf::Arena* arena);
  BoolList(::google::protobuf::Arena* arena, const BoolList& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated bool values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  bool values(int index) const;
  void set_values(int index, bool value);
  void add_values(bool value);
  const ::google::protobuf::RepeatedField<bool>& values() const;
  ::google::protobuf::RepeatedField<bool>* mutable_values();

  private:
  const ::google::protobuf::RepeatedField<bool>& _internal_values() const;
  ::google::protobuf::RepeatedField<bool>* _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.BoolList)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedField<bool> values_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};// -------------------------------------------------------------------

class AttributeProto final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.AttributeProto) */ {
 public:
  inline AttributeProto() : AttributeProto(nullptr) {}
  ~AttributeProto() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AttributeProto(::google::protobuf::internal::ConstantInitialized);

  inline AttributeProto(const AttributeProto& from)
      : AttributeProto(nullptr, from) {}
  AttributeProto(AttributeProto&& from) noexcept
    : AttributeProto() {
    *this = ::std::move(from);
  }

  inline AttributeProto& operator=(const AttributeProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttributeProto& operator=(AttributeProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttributeProto& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kDoubleVal = 3,
    kDoubleList = 4,
    kFloatVal = 5,
    kFloatList = 6,
    kInt32Val = 7,
    kInt32List = 8,
    kInt64Val = 9,
    kInt64List = 10,
    kUint32Val = 11,
    kUint32List = 12,
    kUint64Val = 13,
    kUint64List = 14,
    kSint32Val = 15,
    kSint32List = 16,
    kSint64Val = 17,
    kSint64List = 18,
    kFixed32Val = 19,
    kFixed32List = 20,
    kFixed64Val = 21,
    kFixed64List = 22,
    kSfixed32Val = 23,
    kSfixed32List = 24,
    kSfixed64Val = 25,
    kSfixed64List = 26,
    kBoolVal = 27,
    kBoolList = 28,
    kStringVal = 29,
    kStringList = 30,
    kBytesVal = 31,
    kBytesList = 32,
    VALUE_NOT_SET = 0,
  };

  static inline const AttributeProto* internal_default_instance() {
    return reinterpret_cast<const AttributeProto*>(
               &_AttributeProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AttributeProto& a, AttributeProto& b) {
    a.Swap(&b);
  }
  inline void Swap(AttributeProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttributeProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttributeProto* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AttributeProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AttributeProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AttributeProto& from) {
    AttributeProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AttributeProto* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ChakraProtoMsg.AttributeProto";
  }
  protected:
  explicit AttributeProto(::google::protobuf::Arena* arena);
  AttributeProto(::google::protobuf::Arena* arena, const AttributeProto& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDocStringFieldNumber = 2,
    kDoubleValFieldNumber = 3,
    kDoubleListFieldNumber = 4,
    kFloatValFieldNumber = 5,
    kFloatListFieldNumber = 6,
    kInt32ValFieldNumber = 7,
    kInt32ListFieldNumber = 8,
    kInt64ValFieldNumber = 9,
    kInt64ListFieldNumber = 10,
    kUint32ValFieldNumber = 11,
    kUint32ListFieldNumber = 12,
    kUint64ValFieldNumber = 13,
    kUint64ListFieldNumber = 14,
    kSint32ValFieldNumber = 15,
    kSint32ListFieldNumber = 16,
    kSint64ValFieldNumber = 17,
    kSint64ListFieldNumber = 18,
    kFixed32ValFieldNumber = 19,
    kFixed32ListFieldNumber = 20,
    kFixed64ValFieldNumber = 21,
    kFixed64ListFieldNumber = 22,
    kSfixed32ValFieldNumber = 23,
    kSfixed32ListFieldNumber = 24,
    kSfixed64ValFieldNumber = 25,
    kSfixed64ListFieldNumber = 26,
    kBoolValFieldNumber = 27,
    kBoolListFieldNumber = 28,
    kStringValFieldNumber = 29,
    kStringListFieldNumber = 30,
    kBytesValFieldNumber = 31,
    kBytesListFieldNumber = 32,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string doc_string = 2;
  void clear_doc_string() ;
  const std::string& doc_string() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_doc_string(Arg_&& arg, Args_... args);
  std::string* mutable_doc_string();
  PROTOBUF_NODISCARD std::string* release_doc_string();
  void set_allocated_doc_string(std::string* value);

  private:
  const std::string& _internal_doc_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_doc_string(
      const std::string& value);
  std::string* _internal_mutable_doc_string();

  public:
  // double double_val = 3;
  bool has_double_val() const;
  void clear_double_val() ;
  double double_val() const;
  void set_double_val(double value);

  private:
  double _internal_double_val() const;
  void _internal_set_double_val(double value);

  public:
  // .ChakraProtoMsg.DoubleList double_list = 4;
  bool has_double_list() const;
  private:
  bool _internal_has_double_list() const;

  public:
  void clear_double_list() ;
  const ::ChakraProtoMsg::DoubleList& double_list() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::DoubleList* release_double_list();
  ::ChakraProtoMsg::DoubleList* mutable_double_list();
  void set_allocated_double_list(::ChakraProtoMsg::DoubleList* value);
  void unsafe_arena_set_allocated_double_list(::ChakraProtoMsg::DoubleList* value);
  ::ChakraProtoMsg::DoubleList* unsafe_arena_release_double_list();

  private:
  const ::ChakraProtoMsg::DoubleList& _internal_double_list() const;
  ::ChakraProtoMsg::DoubleList* _internal_mutable_double_list();

  public:
  // float float_val = 5;
  bool has_float_val() const;
  void clear_float_val() ;
  float float_val() const;
  void set_float_val(float value);

  private:
  float _internal_float_val() const;
  void _internal_set_float_val(float value);

  public:
  // .ChakraProtoMsg.FloatList float_list = 6;
  bool has_float_list() const;
  private:
  bool _internal_has_float_list() const;

  public:
  void clear_float_list() ;
  const ::ChakraProtoMsg::FloatList& float_list() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::FloatList* release_float_list();
  ::ChakraProtoMsg::FloatList* mutable_float_list();
  void set_allocated_float_list(::ChakraProtoMsg::FloatList* value);
  void unsafe_arena_set_allocated_float_list(::ChakraProtoMsg::FloatList* value);
  ::ChakraProtoMsg::FloatList* unsafe_arena_release_float_list();

  private:
  const ::ChakraProtoMsg::FloatList& _internal_float_list() const;
  ::ChakraProtoMsg::FloatList* _internal_mutable_float_list();

  public:
  // int32 int32_val = 7;
  bool has_int32_val() const;
  void clear_int32_val() ;
  ::int32_t int32_val() const;
  void set_int32_val(::int32_t value);

  private:
  ::int32_t _internal_int32_val() const;
  void _internal_set_int32_val(::int32_t value);

  public:
  // .ChakraProtoMsg.Int32List int32_list = 8;
  bool has_int32_list() const;
  private:
  bool _internal_has_int32_list() const;

  public:
  void clear_int32_list() ;
  const ::ChakraProtoMsg::Int32List& int32_list() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::Int32List* release_int32_list();
  ::ChakraProtoMsg::Int32List* mutable_int32_list();
  void set_allocated_int32_list(::ChakraProtoMsg::Int32List* value);
  void unsafe_arena_set_allocated_int32_list(::ChakraProtoMsg::Int32List* value);
  ::ChakraProtoMsg::Int32List* unsafe_arena_release_int32_list();

  private:
  const ::ChakraProtoMsg::Int32List& _internal_int32_list() const;
  ::ChakraProtoMsg::Int32List* _internal_mutable_int32_list();

  public:
  // int64 int64_val = 9;
  bool has_int64_val() const;
  void clear_int64_val() ;
  ::int64_t int64_val() const;
  void set_int64_val(::int64_t value);

  private:
  ::int64_t _internal_int64_val() const;
  void _internal_set_int64_val(::int64_t value);

  public:
  // .ChakraProtoMsg.Int64List int64_list = 10;
  bool has_int64_list() const;
  private:
  bool _internal_has_int64_list() const;

  public:
  void clear_int64_list() ;
  const ::ChakraProtoMsg::Int64List& int64_list() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::Int64List* release_int64_list();
  ::ChakraProtoMsg::Int64List* mutable_int64_list();
  void set_allocated_int64_list(::ChakraProtoMsg::Int64List* value);
  void unsafe_arena_set_allocated_int64_list(::ChakraProtoMsg::Int64List* value);
  ::ChakraProtoMsg::Int64List* unsafe_arena_release_int64_list();

  private:
  const ::ChakraProtoMsg::Int64List& _internal_int64_list() const;
  ::ChakraProtoMsg::Int64List* _internal_mutable_int64_list();

  public:
  // uint32 uint32_val = 11;
  bool has_uint32_val() const;
  void clear_uint32_val() ;
  ::uint32_t uint32_val() const;
  void set_uint32_val(::uint32_t value);

  private:
  ::uint32_t _internal_uint32_val() const;
  void _internal_set_uint32_val(::uint32_t value);

  public:
  // .ChakraProtoMsg.Uint32List uint32_list = 12;
  bool has_uint32_list() const;
  private:
  bool _internal_has_uint32_list() const;

  public:
  void clear_uint32_list() ;
  const ::ChakraProtoMsg::Uint32List& uint32_list() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::Uint32List* release_uint32_list();
  ::ChakraProtoMsg::Uint32List* mutable_uint32_list();
  void set_allocated_uint32_list(::ChakraProtoMsg::Uint32List* value);
  void unsafe_arena_set_allocated_uint32_list(::ChakraProtoMsg::Uint32List* value);
  ::ChakraProtoMsg::Uint32List* unsafe_arena_release_uint32_list();

  private:
  const ::ChakraProtoMsg::Uint32List& _internal_uint32_list() const;
  ::ChakraProtoMsg::Uint32List* _internal_mutable_uint32_list();

  public:
  // uint64 uint64_val = 13;
  bool has_uint64_val() const;
  void clear_uint64_val() ;
  ::uint64_t uint64_val() const;
  void set_uint64_val(::uint64_t value);

  private:
  ::uint64_t _internal_uint64_val() const;
  void _internal_set_uint64_val(::uint64_t value);

  public:
  // .ChakraProtoMsg.Uint64List uint64_list = 14;
  bool has_uint64_list() const;
  private:
  bool _internal_has_uint64_list() const;

  public:
  void clear_uint64_list() ;
  const ::ChakraProtoMsg::Uint64List& uint64_list() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::Uint64List* release_uint64_list();
  ::ChakraProtoMsg::Uint64List* mutable_uint64_list();
  void set_allocated_uint64_list(::ChakraProtoMsg::Uint64List* value);
  void unsafe_arena_set_allocated_uint64_list(::ChakraProtoMsg::Uint64List* value);
  ::ChakraProtoMsg::Uint64List* unsafe_arena_release_uint64_list();

  private:
  const ::ChakraProtoMsg::Uint64List& _internal_uint64_list() const;
  ::ChakraProtoMsg::Uint64List* _internal_mutable_uint64_list();

  public:
  // sint32 sint32_val = 15;
  bool has_sint32_val() const;
  void clear_sint32_val() ;
  ::int32_t sint32_val() const;
  void set_sint32_val(::int32_t value);

  private:
  ::int32_t _internal_sint32_val() const;
  void _internal_set_sint32_val(::int32_t value);

  public:
  // .ChakraProtoMsg.Sint32List sint32_list = 16;
  bool has_sint32_list() const;
  private:
  bool _internal_has_sint32_list() const;

  public:
  void clear_sint32_list() ;
  const ::ChakraProtoMsg::Sint32List& sint32_list() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::Sint32List* release_sint32_list();
  ::ChakraProtoMsg::Sint32List* mutable_sint32_list();
  void set_allocated_sint32_list(::ChakraProtoMsg::Sint32List* value);
  void unsafe_arena_set_allocated_sint32_list(::ChakraProtoMsg::Sint32List* value);
  ::ChakraProtoMsg::Sint32List* unsafe_arena_release_sint32_list();

  private:
  const ::ChakraProtoMsg::Sint32List& _internal_sint32_list() const;
  ::ChakraProtoMsg::Sint32List* _internal_mutable_sint32_list();

  public:
  // sint64 sint64_val = 17;
  bool has_sint64_val() const;
  void clear_sint64_val() ;
  ::int64_t sint64_val() const;
  void set_sint64_val(::int64_t value);

  private:
  ::int64_t _internal_sint64_val() const;
  void _internal_set_sint64_val(::int64_t value);

  public:
  // .ChakraProtoMsg.Sint64List sint64_list = 18;
  bool has_sint64_list() const;
  private:
  bool _internal_has_sint64_list() const;

  public:
  void clear_sint64_list() ;
  const ::ChakraProtoMsg::Sint64List& sint64_list() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::Sint64List* release_sint64_list();
  ::ChakraProtoMsg::Sint64List* mutable_sint64_list();
  void set_allocated_sint64_list(::ChakraProtoMsg::Sint64List* value);
  void unsafe_arena_set_allocated_sint64_list(::ChakraProtoMsg::Sint64List* value);
  ::ChakraProtoMsg::Sint64List* unsafe_arena_release_sint64_list();

  private:
  const ::ChakraProtoMsg::Sint64List& _internal_sint64_list() const;
  ::ChakraProtoMsg::Sint64List* _internal_mutable_sint64_list();

  public:
  // fixed32 fixed32_val = 19;
  bool has_fixed32_val() const;
  void clear_fixed32_val() ;
  ::uint32_t fixed32_val() const;
  void set_fixed32_val(::uint32_t value);

  private:
  ::uint32_t _internal_fixed32_val() const;
  void _internal_set_fixed32_val(::uint32_t value);

  public:
  // .ChakraProtoMsg.Fixed32List fixed32_list = 20;
  bool has_fixed32_list() const;
  private:
  bool _internal_has_fixed32_list() const;

  public:
  void clear_fixed32_list() ;
  const ::ChakraProtoMsg::Fixed32List& fixed32_list() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::Fixed32List* release_fixed32_list();
  ::ChakraProtoMsg::Fixed32List* mutable_fixed32_list();
  void set_allocated_fixed32_list(::ChakraProtoMsg::Fixed32List* value);
  void unsafe_arena_set_allocated_fixed32_list(::ChakraProtoMsg::Fixed32List* value);
  ::ChakraProtoMsg::Fixed32List* unsafe_arena_release_fixed32_list();

  private:
  const ::ChakraProtoMsg::Fixed32List& _internal_fixed32_list() const;
  ::ChakraProtoMsg::Fixed32List* _internal_mutable_fixed32_list();

  public:
  // fixed64 fixed64_val = 21;
  bool has_fixed64_val() const;
  void clear_fixed64_val() ;
  ::uint64_t fixed64_val() const;
  void set_fixed64_val(::uint64_t value);

  private:
  ::uint64_t _internal_fixed64_val() const;
  void _internal_set_fixed64_val(::uint64_t value);

  public:
  // .ChakraProtoMsg.Fixed64List fixed64_list = 22;
  bool has_fixed64_list() const;
  private:
  bool _internal_has_fixed64_list() const;

  public:
  void clear_fixed64_list() ;
  const ::ChakraProtoMsg::Fixed64List& fixed64_list() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::Fixed64List* release_fixed64_list();
  ::ChakraProtoMsg::Fixed64List* mutable_fixed64_list();
  void set_allocated_fixed64_list(::ChakraProtoMsg::Fixed64List* value);
  void unsafe_arena_set_allocated_fixed64_list(::ChakraProtoMsg::Fixed64List* value);
  ::ChakraProtoMsg::Fixed64List* unsafe_arena_release_fixed64_list();

  private:
  const ::ChakraProtoMsg::Fixed64List& _internal_fixed64_list() const;
  ::ChakraProtoMsg::Fixed64List* _internal_mutable_fixed64_list();

  public:
  // sfixed32 sfixed32_val = 23;
  bool has_sfixed32_val() const;
  void clear_sfixed32_val() ;
  ::int32_t sfixed32_val() const;
  void set_sfixed32_val(::int32_t value);

  private:
  ::int32_t _internal_sfixed32_val() const;
  void _internal_set_sfixed32_val(::int32_t value);

  public:
  // .ChakraProtoMsg.Sfixed32List sfixed32_list = 24;
  bool has_sfixed32_list() const;
  private:
  bool _internal_has_sfixed32_list() const;

  public:
  void clear_sfixed32_list() ;
  const ::ChakraProtoMsg::Sfixed32List& sfixed32_list() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::Sfixed32List* release_sfixed32_list();
  ::ChakraProtoMsg::Sfixed32List* mutable_sfixed32_list();
  void set_allocated_sfixed32_list(::ChakraProtoMsg::Sfixed32List* value);
  void unsafe_arena_set_allocated_sfixed32_list(::ChakraProtoMsg::Sfixed32List* value);
  ::ChakraProtoMsg::Sfixed32List* unsafe_arena_release_sfixed32_list();

  private:
  const ::ChakraProtoMsg::Sfixed32List& _internal_sfixed32_list() const;
  ::ChakraProtoMsg::Sfixed32List* _internal_mutable_sfixed32_list();

  public:
  // sfixed64 sfixed64_val = 25;
  bool has_sfixed64_val() const;
  void clear_sfixed64_val() ;
  ::int64_t sfixed64_val() const;
  void set_sfixed64_val(::int64_t value);

  private:
  ::int64_t _internal_sfixed64_val() const;
  void _internal_set_sfixed64_val(::int64_t value);

  public:
  // .ChakraProtoMsg.Sfixed64List sfixed64_list = 26;
  bool has_sfixed64_list() const;
  private:
  bool _internal_has_sfixed64_list() const;

  public:
  void clear_sfixed64_list() ;
  const ::ChakraProtoMsg::Sfixed64List& sfixed64_list() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::Sfixed64List* release_sfixed64_list();
  ::ChakraProtoMsg::Sfixed64List* mutable_sfixed64_list();
  void set_allocated_sfixed64_list(::ChakraProtoMsg::Sfixed64List* value);
  void unsafe_arena_set_allocated_sfixed64_list(::ChakraProtoMsg::Sfixed64List* value);
  ::ChakraProtoMsg::Sfixed64List* unsafe_arena_release_sfixed64_list();

  private:
  const ::ChakraProtoMsg::Sfixed64List& _internal_sfixed64_list() const;
  ::ChakraProtoMsg::Sfixed64List* _internal_mutable_sfixed64_list();

  public:
  // bool bool_val = 27;
  bool has_bool_val() const;
  void clear_bool_val() ;
  bool bool_val() const;
  void set_bool_val(bool value);

  private:
  bool _internal_bool_val() const;
  void _internal_set_bool_val(bool value);

  public:
  // .ChakraProtoMsg.BoolList bool_list = 28;
  bool has_bool_list() const;
  private:
  bool _internal_has_bool_list() const;

  public:
  void clear_bool_list() ;
  const ::ChakraProtoMsg::BoolList& bool_list() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::BoolList* release_bool_list();
  ::ChakraProtoMsg::BoolList* mutable_bool_list();
  void set_allocated_bool_list(::ChakraProtoMsg::BoolList* value);
  void unsafe_arena_set_allocated_bool_list(::ChakraProtoMsg::BoolList* value);
  ::ChakraProtoMsg::BoolList* unsafe_arena_release_bool_list();

  private:
  const ::ChakraProtoMsg::BoolList& _internal_bool_list() const;
  ::ChakraProtoMsg::BoolList* _internal_mutable_bool_list();

  public:
  // string string_val = 29;
  bool has_string_val() const;
  void clear_string_val() ;
  const std::string& string_val() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_string_val(Arg_&& arg, Args_... args);
  std::string* mutable_string_val();
  PROTOBUF_NODISCARD std::string* release_string_val();
  void set_allocated_string_val(std::string* value);

  private:
  const std::string& _internal_string_val() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_val(
      const std::string& value);
  std::string* _internal_mutable_string_val();

  public:
  // .ChakraProtoMsg.StringList string_list = 30;
  bool has_string_list() const;
  private:
  bool _internal_has_string_list() const;

  public:
  void clear_string_list() ;
  const ::ChakraProtoMsg::StringList& string_list() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::StringList* release_string_list();
  ::ChakraProtoMsg::StringList* mutable_string_list();
  void set_allocated_string_list(::ChakraProtoMsg::StringList* value);
  void unsafe_arena_set_allocated_string_list(::ChakraProtoMsg::StringList* value);
  ::ChakraProtoMsg::StringList* unsafe_arena_release_string_list();

  private:
  const ::ChakraProtoMsg::StringList& _internal_string_list() const;
  ::ChakraProtoMsg::StringList* _internal_mutable_string_list();

  public:
  // bytes bytes_val = 31;
  bool has_bytes_val() const;
  void clear_bytes_val() ;
  const std::string& bytes_val() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bytes_val(Arg_&& arg, Args_... args);
  std::string* mutable_bytes_val();
  PROTOBUF_NODISCARD std::string* release_bytes_val();
  void set_allocated_bytes_val(std::string* value);

  private:
  const std::string& _internal_bytes_val() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bytes_val(
      const std::string& value);
  std::string* _internal_mutable_bytes_val();

  public:
  // .ChakraProtoMsg.BytesList bytes_list = 32;
  bool has_bytes_list() const;
  private:
  bool _internal_has_bytes_list() const;

  public:
  void clear_bytes_list() ;
  const ::ChakraProtoMsg::BytesList& bytes_list() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::BytesList* release_bytes_list();
  ::ChakraProtoMsg::BytesList* mutable_bytes_list();
  void set_allocated_bytes_list(::ChakraProtoMsg::BytesList* value);
  void unsafe_arena_set_allocated_bytes_list(::ChakraProtoMsg::BytesList* value);
  ::ChakraProtoMsg::BytesList* unsafe_arena_release_bytes_list();

  private:
  const ::ChakraProtoMsg::BytesList& _internal_bytes_list() const;
  ::ChakraProtoMsg::BytesList* _internal_mutable_bytes_list();

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.AttributeProto)
 private:
  class _Internal;
  void set_has_double_val();
  void set_has_double_list();
  void set_has_float_val();
  void set_has_float_list();
  void set_has_int32_val();
  void set_has_int32_list();
  void set_has_int64_val();
  void set_has_int64_list();
  void set_has_uint32_val();
  void set_has_uint32_list();
  void set_has_uint64_val();
  void set_has_uint64_list();
  void set_has_sint32_val();
  void set_has_sint32_list();
  void set_has_sint64_val();
  void set_has_sint64_list();
  void set_has_fixed32_val();
  void set_has_fixed32_list();
  void set_has_fixed64_val();
  void set_has_fixed64_list();
  void set_has_sfixed32_val();
  void set_has_sfixed32_list();
  void set_has_sfixed64_val();
  void set_has_sfixed64_list();
  void set_has_bool_val();
  void set_has_bool_list();
  void set_has_string_val();
  void set_has_string_list();
  void set_has_bytes_val();
  void set_has_bytes_list();

  inline bool has_value() const;
  inline void clear_has_value();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 32, 15,
      94, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr doc_string_;
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      double double_val_;
      ::ChakraProtoMsg::DoubleList* double_list_;
      float float_val_;
      ::ChakraProtoMsg::FloatList* float_list_;
      ::int32_t int32_val_;
      ::ChakraProtoMsg::Int32List* int32_list_;
      ::int64_t int64_val_;
      ::ChakraProtoMsg::Int64List* int64_list_;
      ::uint32_t uint32_val_;
      ::ChakraProtoMsg::Uint32List* uint32_list_;
      ::uint64_t uint64_val_;
      ::ChakraProtoMsg::Uint64List* uint64_list_;
      ::int32_t sint32_val_;
      ::ChakraProtoMsg::Sint32List* sint32_list_;
      ::int64_t sint64_val_;
      ::ChakraProtoMsg::Sint64List* sint64_list_;
      ::uint32_t fixed32_val_;
      ::ChakraProtoMsg::Fixed32List* fixed32_list_;
      ::uint64_t fixed64_val_;
      ::ChakraProtoMsg::Fixed64List* fixed64_list_;
      ::int32_t sfixed32_val_;
      ::ChakraProtoMsg::Sfixed32List* sfixed32_list_;
      ::int64_t sfixed64_val_;
      ::ChakraProtoMsg::Sfixed64List* sfixed64_list_;
      bool bool_val_;
      ::ChakraProtoMsg::BoolList* bool_list_;
      ::google::protobuf::internal::ArenaStringPtr string_val_;
      ::ChakraProtoMsg::StringList* string_list_;
      ::google::protobuf::internal::ArenaStringPtr bytes_val_;
      ::ChakraProtoMsg::BytesList* bytes_list_;
    } value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};// -------------------------------------------------------------------

class Node final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Node) */ {
 public:
  inline Node() : Node(nullptr) {}
  ~Node() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Node(::google::protobuf::internal::ConstantInitialized);

  inline Node(const Node& from)
      : Node(nullptr, from) {}
  Node(Node&& from) noexcept
    : Node() {
    *this = ::std::move(from);
  }

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  inline Node& operator=(Node&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Node& default_instance() {
    return *internal_default_instance();
  }
  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Node& a, Node& b) {
    a.Swap(&b);
  }
  inline void Swap(Node* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Node* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Node* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Node>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Node& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Node& from) {
    Node::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Node* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ChakraProtoMsg.Node";
  }
  protected:
  explicit Node(::google::protobuf::Arena* arena);
  Node(::google::protobuf::Arena* arena, const Node& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCtrlDepsFieldNumber = 4,
    kDataDepsFieldNumber = 5,
    kAttrFieldNumber = 10,
    kNameFieldNumber = 2,
    kInputsFieldNumber = 8,
    kOutputsFieldNumber = 9,
    kIdFieldNumber = 1,
    kStartTimeMicrosFieldNumber = 6,
    kDurationMicrosFieldNumber = 7,
    kTypeFieldNumber = 3,
  };
  // repeated uint64 ctrl_deps = 4;
  int ctrl_deps_size() const;
  private:
  int _internal_ctrl_deps_size() const;

  public:
  void clear_ctrl_deps() ;
  ::uint64_t ctrl_deps(int index) const;
  void set_ctrl_deps(int index, ::uint64_t value);
  void add_ctrl_deps(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& ctrl_deps() const;
  ::google::protobuf::RepeatedField<::uint64_t>* mutable_ctrl_deps();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_ctrl_deps() const;
  ::google::protobuf::RepeatedField<::uint64_t>* _internal_mutable_ctrl_deps();

  public:
  // repeated uint64 data_deps = 5;
  int data_deps_size() const;
  private:
  int _internal_data_deps_size() const;

  public:
  void clear_data_deps() ;
  ::uint64_t data_deps(int index) const;
  void set_data_deps(int index, ::uint64_t value);
  void add_data_deps(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& data_deps() const;
  ::google::protobuf::RepeatedField<::uint64_t>* mutable_data_deps();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_data_deps() const;
  ::google::protobuf::RepeatedField<::uint64_t>* _internal_mutable_data_deps();

  public:
  // repeated .ChakraProtoMsg.AttributeProto attr = 10;
  int attr_size() const;
  private:
  int _internal_attr_size() const;

  public:
  void clear_attr() ;
  ::ChakraProtoMsg::AttributeProto* mutable_attr(int index);
  ::google::protobuf::RepeatedPtrField< ::ChakraProtoMsg::AttributeProto >*
      mutable_attr();
  private:
  const ::google::protobuf::RepeatedPtrField<::ChakraProtoMsg::AttributeProto>& _internal_attr() const;
  ::google::protobuf::RepeatedPtrField<::ChakraProtoMsg::AttributeProto>* _internal_mutable_attr();
  public:
  const ::ChakraProtoMsg::AttributeProto& attr(int index) const;
  ::ChakraProtoMsg::AttributeProto* add_attr();
  const ::google::protobuf::RepeatedPtrField< ::ChakraProtoMsg::AttributeProto >&
      attr() const;
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .ChakraProtoMsg.IOInfo inputs = 8;
  bool has_inputs() const;
  void clear_inputs() ;
  const ::ChakraProtoMsg::IOInfo& inputs() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::IOInfo* release_inputs();
  ::ChakraProtoMsg::IOInfo* mutable_inputs();
  void set_allocated_inputs(::ChakraProtoMsg::IOInfo* value);
  void unsafe_arena_set_allocated_inputs(::ChakraProtoMsg::IOInfo* value);
  ::ChakraProtoMsg::IOInfo* unsafe_arena_release_inputs();

  private:
  const ::ChakraProtoMsg::IOInfo& _internal_inputs() const;
  ::ChakraProtoMsg::IOInfo* _internal_mutable_inputs();

  public:
  // .ChakraProtoMsg.IOInfo outputs = 9;
  bool has_outputs() const;
  void clear_outputs() ;
  const ::ChakraProtoMsg::IOInfo& outputs() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::IOInfo* release_outputs();
  ::ChakraProtoMsg::IOInfo* mutable_outputs();
  void set_allocated_outputs(::ChakraProtoMsg::IOInfo* value);
  void unsafe_arena_set_allocated_outputs(::ChakraProtoMsg::IOInfo* value);
  ::ChakraProtoMsg::IOInfo* unsafe_arena_release_outputs();

  private:
  const ::ChakraProtoMsg::IOInfo& _internal_outputs() const;
  ::ChakraProtoMsg::IOInfo* _internal_mutable_outputs();

  public:
  // uint64 id = 1;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // uint64 start_time_micros = 6;
  void clear_start_time_micros() ;
  ::uint64_t start_time_micros() const;
  void set_start_time_micros(::uint64_t value);

  private:
  ::uint64_t _internal_start_time_micros() const;
  void _internal_set_start_time_micros(::uint64_t value);

  public:
  // uint64 duration_micros = 7;
  void clear_duration_micros() ;
  ::uint64_t duration_micros() const;
  void set_duration_micros(::uint64_t value);

  private:
  ::uint64_t _internal_duration_micros() const;
  void _internal_set_duration_micros(::uint64_t value);

  public:
  // .ChakraProtoMsg.NodeType type = 3;
  void clear_type() ;
  ::ChakraProtoMsg::NodeType type() const;
  void set_type(::ChakraProtoMsg::NodeType value);

  private:
  ::ChakraProtoMsg::NodeType _internal_type() const;
  void _internal_set_type(::ChakraProtoMsg::NodeType value);

  public:
  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Node)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 3,
      40, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint64_t> ctrl_deps_;
    mutable ::google::protobuf::internal::CachedSize _ctrl_deps_cached_byte_size_;
    ::google::protobuf::RepeatedField<::uint64_t> data_deps_;
    mutable ::google::protobuf::internal::CachedSize _data_deps_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField< ::ChakraProtoMsg::AttributeProto > attr_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::ChakraProtoMsg::IOInfo* inputs_;
    ::ChakraProtoMsg::IOInfo* outputs_;
    ::uint64_t id_;
    ::uint64_t start_time_micros_;
    ::uint64_t duration_micros_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};// -------------------------------------------------------------------

class GlobalMetadata final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.GlobalMetadata) */ {
 public:
  inline GlobalMetadata() : GlobalMetadata(nullptr) {}
  ~GlobalMetadata() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GlobalMetadata(::google::protobuf::internal::ConstantInitialized);

  inline GlobalMetadata(const GlobalMetadata& from)
      : GlobalMetadata(nullptr, from) {}
  GlobalMetadata(GlobalMetadata&& from) noexcept
    : GlobalMetadata() {
    *this = ::std::move(from);
  }

  inline GlobalMetadata& operator=(const GlobalMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline GlobalMetadata& operator=(GlobalMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GlobalMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const GlobalMetadata* internal_default_instance() {
    return reinterpret_cast<const GlobalMetadata*>(
               &_GlobalMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GlobalMetadata& a, GlobalMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(GlobalMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GlobalMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GlobalMetadata* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GlobalMetadata>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GlobalMetadata& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GlobalMetadata& from) {
    GlobalMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GlobalMetadata* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ChakraProtoMsg.GlobalMetadata";
  }
  protected:
  explicit GlobalMetadata(::google::protobuf::Arena* arena);
  GlobalMetadata(::google::protobuf::Arena* arena, const GlobalMetadata& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttrFieldNumber = 2,
    kVersionFieldNumber = 1,
  };
  // repeated .ChakraProtoMsg.AttributeProto attr = 2;
  int attr_size() const;
  private:
  int _internal_attr_size() const;

  public:
  void clear_attr() ;
  ::ChakraProtoMsg::AttributeProto* mutable_attr(int index);
  ::google::protobuf::RepeatedPtrField< ::ChakraProtoMsg::AttributeProto >*
      mutable_attr();
  private:
  const ::google::protobuf::RepeatedPtrField<::ChakraProtoMsg::AttributeProto>& _internal_attr() const;
  ::google::protobuf::RepeatedPtrField<::ChakraProtoMsg::AttributeProto>* _internal_mutable_attr();
  public:
  const ::ChakraProtoMsg::AttributeProto& attr(int index) const;
  ::ChakraProtoMsg::AttributeProto* add_attr();
  const ::google::protobuf::RepeatedPtrField< ::ChakraProtoMsg::AttributeProto >&
      attr() const;
  // string version = 1;
  void clear_version() ;
  const std::string& version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* value);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.GlobalMetadata)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      45, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::ChakraProtoMsg::AttributeProto > attr_;
    ::google::protobuf::internal::ArenaStringPtr version_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// AttributeProto

// string name = 1;
inline void AttributeProto::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& AttributeProto::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AttributeProto::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.name)
}
inline std::string* AttributeProto::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.name)
  return _s;
}
inline const std::string& AttributeProto::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void AttributeProto::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* AttributeProto::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* AttributeProto::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.name)
  return _impl_.name_.Release();
}
inline void AttributeProto::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.AttributeProto.name)
}

// string doc_string = 2;
inline void AttributeProto::clear_doc_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.doc_string_.ClearToEmpty();
}
inline const std::string& AttributeProto::doc_string() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.doc_string)
  return _internal_doc_string();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AttributeProto::set_doc_string(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.doc_string_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.doc_string)
}
inline std::string* AttributeProto::mutable_doc_string() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_doc_string();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.doc_string)
  return _s;
}
inline const std::string& AttributeProto::_internal_doc_string() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.doc_string_.Get();
}
inline void AttributeProto::_internal_set_doc_string(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.doc_string_.Set(value, GetArena());
}
inline std::string* AttributeProto::_internal_mutable_doc_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.doc_string_.Mutable( GetArena());
}
inline std::string* AttributeProto::release_doc_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.doc_string)
  return _impl_.doc_string_.Release();
}
inline void AttributeProto::set_allocated_doc_string(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.doc_string_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.doc_string_.IsDefault()) {
          _impl_.doc_string_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.AttributeProto.doc_string)
}

// double double_val = 3;
inline bool AttributeProto::has_double_val() const {
  return value_case() == kDoubleVal;
}
inline void AttributeProto::set_has_double_val() {
  _impl_._oneof_case_[0] = kDoubleVal;
}
inline void AttributeProto::clear_double_val() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kDoubleVal) {
    _impl_.value_.double_val_ = 0;
    clear_has_value();
  }
}
inline double AttributeProto::double_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.double_val)
  return _internal_double_val();
}
inline void AttributeProto::set_double_val(double value) {
  _internal_set_double_val(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.double_val)
}
inline double AttributeProto::_internal_double_val() const {
  if (value_case() == kDoubleVal) {
    return _impl_.value_.double_val_;
  }
  return 0;
}
inline void AttributeProto::_internal_set_double_val(double value) {
  if (value_case() != kDoubleVal) {
    clear_value();
    set_has_double_val();
  }
  _impl_.value_.double_val_ = value;
}

// .ChakraProtoMsg.DoubleList double_list = 4;
inline bool AttributeProto::has_double_list() const {
  return value_case() == kDoubleList;
}
inline bool AttributeProto::_internal_has_double_list() const {
  return value_case() == kDoubleList;
}
inline void AttributeProto::set_has_double_list() {
  _impl_._oneof_case_[0] = kDoubleList;
}
inline void AttributeProto::clear_double_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kDoubleList) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.double_list_;
    }
    clear_has_value();
  }
}
inline ::ChakraProtoMsg::DoubleList* AttributeProto::release_double_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.double_list)
  if (value_case() == kDoubleList) {
    clear_has_value();
    auto* temp = _impl_.value_.double_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.double_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChakraProtoMsg::DoubleList& AttributeProto::_internal_double_list() const {
  return value_case() == kDoubleList ? *_impl_.value_.double_list_ : reinterpret_cast<::ChakraProtoMsg::DoubleList&>(::ChakraProtoMsg::_DoubleList_default_instance_);
}
inline const ::ChakraProtoMsg::DoubleList& AttributeProto::double_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.double_list)
  return _internal_double_list();
}
inline ::ChakraProtoMsg::DoubleList* AttributeProto::unsafe_arena_release_double_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ChakraProtoMsg.AttributeProto.double_list)
  if (value_case() == kDoubleList) {
    clear_has_value();
    auto* temp = _impl_.value_.double_list_;
    _impl_.value_.double_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeProto::unsafe_arena_set_allocated_double_list(::ChakraProtoMsg::DoubleList* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_double_list();
    _impl_.value_.double_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.AttributeProto.double_list)
}
inline ::ChakraProtoMsg::DoubleList* AttributeProto::_internal_mutable_double_list() {
  if (value_case() != kDoubleList) {
    clear_value();
    set_has_double_list();
    _impl_.value_.double_list_ = CreateMaybeMessage<::ChakraProtoMsg::DoubleList>(GetArena());
  }
  return _impl_.value_.double_list_;
}
inline ::ChakraProtoMsg::DoubleList* AttributeProto::mutable_double_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ChakraProtoMsg::DoubleList* _msg = _internal_mutable_double_list();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.double_list)
  return _msg;
}

// float float_val = 5;
inline bool AttributeProto::has_float_val() const {
  return value_case() == kFloatVal;
}
inline void AttributeProto::set_has_float_val() {
  _impl_._oneof_case_[0] = kFloatVal;
}
inline void AttributeProto::clear_float_val() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kFloatVal) {
    _impl_.value_.float_val_ = 0;
    clear_has_value();
  }
}
inline float AttributeProto::float_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.float_val)
  return _internal_float_val();
}
inline void AttributeProto::set_float_val(float value) {
  _internal_set_float_val(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.float_val)
}
inline float AttributeProto::_internal_float_val() const {
  if (value_case() == kFloatVal) {
    return _impl_.value_.float_val_;
  }
  return 0;
}
inline void AttributeProto::_internal_set_float_val(float value) {
  if (value_case() != kFloatVal) {
    clear_value();
    set_has_float_val();
  }
  _impl_.value_.float_val_ = value;
}

// .ChakraProtoMsg.FloatList float_list = 6;
inline bool AttributeProto::has_float_list() const {
  return value_case() == kFloatList;
}
inline bool AttributeProto::_internal_has_float_list() const {
  return value_case() == kFloatList;
}
inline void AttributeProto::set_has_float_list() {
  _impl_._oneof_case_[0] = kFloatList;
}
inline void AttributeProto::clear_float_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kFloatList) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.float_list_;
    }
    clear_has_value();
  }
}
inline ::ChakraProtoMsg::FloatList* AttributeProto::release_float_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.float_list)
  if (value_case() == kFloatList) {
    clear_has_value();
    auto* temp = _impl_.value_.float_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.float_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChakraProtoMsg::FloatList& AttributeProto::_internal_float_list() const {
  return value_case() == kFloatList ? *_impl_.value_.float_list_ : reinterpret_cast<::ChakraProtoMsg::FloatList&>(::ChakraProtoMsg::_FloatList_default_instance_);
}
inline const ::ChakraProtoMsg::FloatList& AttributeProto::float_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.float_list)
  return _internal_float_list();
}
inline ::ChakraProtoMsg::FloatList* AttributeProto::unsafe_arena_release_float_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ChakraProtoMsg.AttributeProto.float_list)
  if (value_case() == kFloatList) {
    clear_has_value();
    auto* temp = _impl_.value_.float_list_;
    _impl_.value_.float_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeProto::unsafe_arena_set_allocated_float_list(::ChakraProtoMsg::FloatList* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_float_list();
    _impl_.value_.float_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.AttributeProto.float_list)
}
inline ::ChakraProtoMsg::FloatList* AttributeProto::_internal_mutable_float_list() {
  if (value_case() != kFloatList) {
    clear_value();
    set_has_float_list();
    _impl_.value_.float_list_ = CreateMaybeMessage<::ChakraProtoMsg::FloatList>(GetArena());
  }
  return _impl_.value_.float_list_;
}
inline ::ChakraProtoMsg::FloatList* AttributeProto::mutable_float_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ChakraProtoMsg::FloatList* _msg = _internal_mutable_float_list();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.float_list)
  return _msg;
}

// int32 int32_val = 7;
inline bool AttributeProto::has_int32_val() const {
  return value_case() == kInt32Val;
}
inline void AttributeProto::set_has_int32_val() {
  _impl_._oneof_case_[0] = kInt32Val;
}
inline void AttributeProto::clear_int32_val() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kInt32Val) {
    _impl_.value_.int32_val_ = 0;
    clear_has_value();
  }
}
inline ::int32_t AttributeProto::int32_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.int32_val)
  return _internal_int32_val();
}
inline void AttributeProto::set_int32_val(::int32_t value) {
  _internal_set_int32_val(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.int32_val)
}
inline ::int32_t AttributeProto::_internal_int32_val() const {
  if (value_case() == kInt32Val) {
    return _impl_.value_.int32_val_;
  }
  return 0;
}
inline void AttributeProto::_internal_set_int32_val(::int32_t value) {
  if (value_case() != kInt32Val) {
    clear_value();
    set_has_int32_val();
  }
  _impl_.value_.int32_val_ = value;
}

// .ChakraProtoMsg.Int32List int32_list = 8;
inline bool AttributeProto::has_int32_list() const {
  return value_case() == kInt32List;
}
inline bool AttributeProto::_internal_has_int32_list() const {
  return value_case() == kInt32List;
}
inline void AttributeProto::set_has_int32_list() {
  _impl_._oneof_case_[0] = kInt32List;
}
inline void AttributeProto::clear_int32_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kInt32List) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.int32_list_;
    }
    clear_has_value();
  }
}
inline ::ChakraProtoMsg::Int32List* AttributeProto::release_int32_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.int32_list)
  if (value_case() == kInt32List) {
    clear_has_value();
    auto* temp = _impl_.value_.int32_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.int32_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChakraProtoMsg::Int32List& AttributeProto::_internal_int32_list() const {
  return value_case() == kInt32List ? *_impl_.value_.int32_list_ : reinterpret_cast<::ChakraProtoMsg::Int32List&>(::ChakraProtoMsg::_Int32List_default_instance_);
}
inline const ::ChakraProtoMsg::Int32List& AttributeProto::int32_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.int32_list)
  return _internal_int32_list();
}
inline ::ChakraProtoMsg::Int32List* AttributeProto::unsafe_arena_release_int32_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ChakraProtoMsg.AttributeProto.int32_list)
  if (value_case() == kInt32List) {
    clear_has_value();
    auto* temp = _impl_.value_.int32_list_;
    _impl_.value_.int32_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeProto::unsafe_arena_set_allocated_int32_list(::ChakraProtoMsg::Int32List* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_int32_list();
    _impl_.value_.int32_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.AttributeProto.int32_list)
}
inline ::ChakraProtoMsg::Int32List* AttributeProto::_internal_mutable_int32_list() {
  if (value_case() != kInt32List) {
    clear_value();
    set_has_int32_list();
    _impl_.value_.int32_list_ = CreateMaybeMessage<::ChakraProtoMsg::Int32List>(GetArena());
  }
  return _impl_.value_.int32_list_;
}
inline ::ChakraProtoMsg::Int32List* AttributeProto::mutable_int32_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ChakraProtoMsg::Int32List* _msg = _internal_mutable_int32_list();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.int32_list)
  return _msg;
}

// int64 int64_val = 9;
inline bool AttributeProto::has_int64_val() const {
  return value_case() == kInt64Val;
}
inline void AttributeProto::set_has_int64_val() {
  _impl_._oneof_case_[0] = kInt64Val;
}
inline void AttributeProto::clear_int64_val() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kInt64Val) {
    _impl_.value_.int64_val_ = ::int64_t{0};
    clear_has_value();
  }
}
inline ::int64_t AttributeProto::int64_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.int64_val)
  return _internal_int64_val();
}
inline void AttributeProto::set_int64_val(::int64_t value) {
  _internal_set_int64_val(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.int64_val)
}
inline ::int64_t AttributeProto::_internal_int64_val() const {
  if (value_case() == kInt64Val) {
    return _impl_.value_.int64_val_;
  }
  return ::int64_t{0};
}
inline void AttributeProto::_internal_set_int64_val(::int64_t value) {
  if (value_case() != kInt64Val) {
    clear_value();
    set_has_int64_val();
  }
  _impl_.value_.int64_val_ = value;
}

// .ChakraProtoMsg.Int64List int64_list = 10;
inline bool AttributeProto::has_int64_list() const {
  return value_case() == kInt64List;
}
inline bool AttributeProto::_internal_has_int64_list() const {
  return value_case() == kInt64List;
}
inline void AttributeProto::set_has_int64_list() {
  _impl_._oneof_case_[0] = kInt64List;
}
inline void AttributeProto::clear_int64_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kInt64List) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.int64_list_;
    }
    clear_has_value();
  }
}
inline ::ChakraProtoMsg::Int64List* AttributeProto::release_int64_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.int64_list)
  if (value_case() == kInt64List) {
    clear_has_value();
    auto* temp = _impl_.value_.int64_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.int64_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChakraProtoMsg::Int64List& AttributeProto::_internal_int64_list() const {
  return value_case() == kInt64List ? *_impl_.value_.int64_list_ : reinterpret_cast<::ChakraProtoMsg::Int64List&>(::ChakraProtoMsg::_Int64List_default_instance_);
}
inline const ::ChakraProtoMsg::Int64List& AttributeProto::int64_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.int64_list)
  return _internal_int64_list();
}
inline ::ChakraProtoMsg::Int64List* AttributeProto::unsafe_arena_release_int64_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ChakraProtoMsg.AttributeProto.int64_list)
  if (value_case() == kInt64List) {
    clear_has_value();
    auto* temp = _impl_.value_.int64_list_;
    _impl_.value_.int64_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeProto::unsafe_arena_set_allocated_int64_list(::ChakraProtoMsg::Int64List* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_int64_list();
    _impl_.value_.int64_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.AttributeProto.int64_list)
}
inline ::ChakraProtoMsg::Int64List* AttributeProto::_internal_mutable_int64_list() {
  if (value_case() != kInt64List) {
    clear_value();
    set_has_int64_list();
    _impl_.value_.int64_list_ = CreateMaybeMessage<::ChakraProtoMsg::Int64List>(GetArena());
  }
  return _impl_.value_.int64_list_;
}
inline ::ChakraProtoMsg::Int64List* AttributeProto::mutable_int64_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ChakraProtoMsg::Int64List* _msg = _internal_mutable_int64_list();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.int64_list)
  return _msg;
}

// uint32 uint32_val = 11;
inline bool AttributeProto::has_uint32_val() const {
  return value_case() == kUint32Val;
}
inline void AttributeProto::set_has_uint32_val() {
  _impl_._oneof_case_[0] = kUint32Val;
}
inline void AttributeProto::clear_uint32_val() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kUint32Val) {
    _impl_.value_.uint32_val_ = 0u;
    clear_has_value();
  }
}
inline ::uint32_t AttributeProto::uint32_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.uint32_val)
  return _internal_uint32_val();
}
inline void AttributeProto::set_uint32_val(::uint32_t value) {
  _internal_set_uint32_val(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.uint32_val)
}
inline ::uint32_t AttributeProto::_internal_uint32_val() const {
  if (value_case() == kUint32Val) {
    return _impl_.value_.uint32_val_;
  }
  return 0u;
}
inline void AttributeProto::_internal_set_uint32_val(::uint32_t value) {
  if (value_case() != kUint32Val) {
    clear_value();
    set_has_uint32_val();
  }
  _impl_.value_.uint32_val_ = value;
}

// .ChakraProtoMsg.Uint32List uint32_list = 12;
inline bool AttributeProto::has_uint32_list() const {
  return value_case() == kUint32List;
}
inline bool AttributeProto::_internal_has_uint32_list() const {
  return value_case() == kUint32List;
}
inline void AttributeProto::set_has_uint32_list() {
  _impl_._oneof_case_[0] = kUint32List;
}
inline void AttributeProto::clear_uint32_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kUint32List) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.uint32_list_;
    }
    clear_has_value();
  }
}
inline ::ChakraProtoMsg::Uint32List* AttributeProto::release_uint32_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.uint32_list)
  if (value_case() == kUint32List) {
    clear_has_value();
    auto* temp = _impl_.value_.uint32_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.uint32_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChakraProtoMsg::Uint32List& AttributeProto::_internal_uint32_list() const {
  return value_case() == kUint32List ? *_impl_.value_.uint32_list_ : reinterpret_cast<::ChakraProtoMsg::Uint32List&>(::ChakraProtoMsg::_Uint32List_default_instance_);
}
inline const ::ChakraProtoMsg::Uint32List& AttributeProto::uint32_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.uint32_list)
  return _internal_uint32_list();
}
inline ::ChakraProtoMsg::Uint32List* AttributeProto::unsafe_arena_release_uint32_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ChakraProtoMsg.AttributeProto.uint32_list)
  if (value_case() == kUint32List) {
    clear_has_value();
    auto* temp = _impl_.value_.uint32_list_;
    _impl_.value_.uint32_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeProto::unsafe_arena_set_allocated_uint32_list(::ChakraProtoMsg::Uint32List* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_uint32_list();
    _impl_.value_.uint32_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.AttributeProto.uint32_list)
}
inline ::ChakraProtoMsg::Uint32List* AttributeProto::_internal_mutable_uint32_list() {
  if (value_case() != kUint32List) {
    clear_value();
    set_has_uint32_list();
    _impl_.value_.uint32_list_ = CreateMaybeMessage<::ChakraProtoMsg::Uint32List>(GetArena());
  }
  return _impl_.value_.uint32_list_;
}
inline ::ChakraProtoMsg::Uint32List* AttributeProto::mutable_uint32_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ChakraProtoMsg::Uint32List* _msg = _internal_mutable_uint32_list();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.uint32_list)
  return _msg;
}

// uint64 uint64_val = 13;
inline bool AttributeProto::has_uint64_val() const {
  return value_case() == kUint64Val;
}
inline void AttributeProto::set_has_uint64_val() {
  _impl_._oneof_case_[0] = kUint64Val;
}
inline void AttributeProto::clear_uint64_val() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kUint64Val) {
    _impl_.value_.uint64_val_ = ::uint64_t{0u};
    clear_has_value();
  }
}
inline ::uint64_t AttributeProto::uint64_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.uint64_val)
  return _internal_uint64_val();
}
inline void AttributeProto::set_uint64_val(::uint64_t value) {
  _internal_set_uint64_val(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.uint64_val)
}
inline ::uint64_t AttributeProto::_internal_uint64_val() const {
  if (value_case() == kUint64Val) {
    return _impl_.value_.uint64_val_;
  }
  return ::uint64_t{0u};
}
inline void AttributeProto::_internal_set_uint64_val(::uint64_t value) {
  if (value_case() != kUint64Val) {
    clear_value();
    set_has_uint64_val();
  }
  _impl_.value_.uint64_val_ = value;
}

// .ChakraProtoMsg.Uint64List uint64_list = 14;
inline bool AttributeProto::has_uint64_list() const {
  return value_case() == kUint64List;
}
inline bool AttributeProto::_internal_has_uint64_list() const {
  return value_case() == kUint64List;
}
inline void AttributeProto::set_has_uint64_list() {
  _impl_._oneof_case_[0] = kUint64List;
}
inline void AttributeProto::clear_uint64_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kUint64List) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.uint64_list_;
    }
    clear_has_value();
  }
}
inline ::ChakraProtoMsg::Uint64List* AttributeProto::release_uint64_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.uint64_list)
  if (value_case() == kUint64List) {
    clear_has_value();
    auto* temp = _impl_.value_.uint64_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.uint64_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChakraProtoMsg::Uint64List& AttributeProto::_internal_uint64_list() const {
  return value_case() == kUint64List ? *_impl_.value_.uint64_list_ : reinterpret_cast<::ChakraProtoMsg::Uint64List&>(::ChakraProtoMsg::_Uint64List_default_instance_);
}
inline const ::ChakraProtoMsg::Uint64List& AttributeProto::uint64_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.uint64_list)
  return _internal_uint64_list();
}
inline ::ChakraProtoMsg::Uint64List* AttributeProto::unsafe_arena_release_uint64_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ChakraProtoMsg.AttributeProto.uint64_list)
  if (value_case() == kUint64List) {
    clear_has_value();
    auto* temp = _impl_.value_.uint64_list_;
    _impl_.value_.uint64_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeProto::unsafe_arena_set_allocated_uint64_list(::ChakraProtoMsg::Uint64List* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_uint64_list();
    _impl_.value_.uint64_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.AttributeProto.uint64_list)
}
inline ::ChakraProtoMsg::Uint64List* AttributeProto::_internal_mutable_uint64_list() {
  if (value_case() != kUint64List) {
    clear_value();
    set_has_uint64_list();
    _impl_.value_.uint64_list_ = CreateMaybeMessage<::ChakraProtoMsg::Uint64List>(GetArena());
  }
  return _impl_.value_.uint64_list_;
}
inline ::ChakraProtoMsg::Uint64List* AttributeProto::mutable_uint64_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ChakraProtoMsg::Uint64List* _msg = _internal_mutable_uint64_list();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.uint64_list)
  return _msg;
}

// sint32 sint32_val = 15;
inline bool AttributeProto::has_sint32_val() const {
  return value_case() == kSint32Val;
}
inline void AttributeProto::set_has_sint32_val() {
  _impl_._oneof_case_[0] = kSint32Val;
}
inline void AttributeProto::clear_sint32_val() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kSint32Val) {
    _impl_.value_.sint32_val_ = 0;
    clear_has_value();
  }
}
inline ::int32_t AttributeProto::sint32_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.sint32_val)
  return _internal_sint32_val();
}
inline void AttributeProto::set_sint32_val(::int32_t value) {
  _internal_set_sint32_val(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.sint32_val)
}
inline ::int32_t AttributeProto::_internal_sint32_val() const {
  if (value_case() == kSint32Val) {
    return _impl_.value_.sint32_val_;
  }
  return 0;
}
inline void AttributeProto::_internal_set_sint32_val(::int32_t value) {
  if (value_case() != kSint32Val) {
    clear_value();
    set_has_sint32_val();
  }
  _impl_.value_.sint32_val_ = value;
}

// .ChakraProtoMsg.Sint32List sint32_list = 16;
inline bool AttributeProto::has_sint32_list() const {
  return value_case() == kSint32List;
}
inline bool AttributeProto::_internal_has_sint32_list() const {
  return value_case() == kSint32List;
}
inline void AttributeProto::set_has_sint32_list() {
  _impl_._oneof_case_[0] = kSint32List;
}
inline void AttributeProto::clear_sint32_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kSint32List) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.sint32_list_;
    }
    clear_has_value();
  }
}
inline ::ChakraProtoMsg::Sint32List* AttributeProto::release_sint32_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.sint32_list)
  if (value_case() == kSint32List) {
    clear_has_value();
    auto* temp = _impl_.value_.sint32_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.sint32_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChakraProtoMsg::Sint32List& AttributeProto::_internal_sint32_list() const {
  return value_case() == kSint32List ? *_impl_.value_.sint32_list_ : reinterpret_cast<::ChakraProtoMsg::Sint32List&>(::ChakraProtoMsg::_Sint32List_default_instance_);
}
inline const ::ChakraProtoMsg::Sint32List& AttributeProto::sint32_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.sint32_list)
  return _internal_sint32_list();
}
inline ::ChakraProtoMsg::Sint32List* AttributeProto::unsafe_arena_release_sint32_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ChakraProtoMsg.AttributeProto.sint32_list)
  if (value_case() == kSint32List) {
    clear_has_value();
    auto* temp = _impl_.value_.sint32_list_;
    _impl_.value_.sint32_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeProto::unsafe_arena_set_allocated_sint32_list(::ChakraProtoMsg::Sint32List* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_sint32_list();
    _impl_.value_.sint32_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.AttributeProto.sint32_list)
}
inline ::ChakraProtoMsg::Sint32List* AttributeProto::_internal_mutable_sint32_list() {
  if (value_case() != kSint32List) {
    clear_value();
    set_has_sint32_list();
    _impl_.value_.sint32_list_ = CreateMaybeMessage<::ChakraProtoMsg::Sint32List>(GetArena());
  }
  return _impl_.value_.sint32_list_;
}
inline ::ChakraProtoMsg::Sint32List* AttributeProto::mutable_sint32_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ChakraProtoMsg::Sint32List* _msg = _internal_mutable_sint32_list();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.sint32_list)
  return _msg;
}

// sint64 sint64_val = 17;
inline bool AttributeProto::has_sint64_val() const {
  return value_case() == kSint64Val;
}
inline void AttributeProto::set_has_sint64_val() {
  _impl_._oneof_case_[0] = kSint64Val;
}
inline void AttributeProto::clear_sint64_val() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kSint64Val) {
    _impl_.value_.sint64_val_ = ::int64_t{0};
    clear_has_value();
  }
}
inline ::int64_t AttributeProto::sint64_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.sint64_val)
  return _internal_sint64_val();
}
inline void AttributeProto::set_sint64_val(::int64_t value) {
  _internal_set_sint64_val(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.sint64_val)
}
inline ::int64_t AttributeProto::_internal_sint64_val() const {
  if (value_case() == kSint64Val) {
    return _impl_.value_.sint64_val_;
  }
  return ::int64_t{0};
}
inline void AttributeProto::_internal_set_sint64_val(::int64_t value) {
  if (value_case() != kSint64Val) {
    clear_value();
    set_has_sint64_val();
  }
  _impl_.value_.sint64_val_ = value;
}

// .ChakraProtoMsg.Sint64List sint64_list = 18;
inline bool AttributeProto::has_sint64_list() const {
  return value_case() == kSint64List;
}
inline bool AttributeProto::_internal_has_sint64_list() const {
  return value_case() == kSint64List;
}
inline void AttributeProto::set_has_sint64_list() {
  _impl_._oneof_case_[0] = kSint64List;
}
inline void AttributeProto::clear_sint64_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kSint64List) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.sint64_list_;
    }
    clear_has_value();
  }
}
inline ::ChakraProtoMsg::Sint64List* AttributeProto::release_sint64_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.sint64_list)
  if (value_case() == kSint64List) {
    clear_has_value();
    auto* temp = _impl_.value_.sint64_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.sint64_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChakraProtoMsg::Sint64List& AttributeProto::_internal_sint64_list() const {
  return value_case() == kSint64List ? *_impl_.value_.sint64_list_ : reinterpret_cast<::ChakraProtoMsg::Sint64List&>(::ChakraProtoMsg::_Sint64List_default_instance_);
}
inline const ::ChakraProtoMsg::Sint64List& AttributeProto::sint64_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.sint64_list)
  return _internal_sint64_list();
}
inline ::ChakraProtoMsg::Sint64List* AttributeProto::unsafe_arena_release_sint64_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ChakraProtoMsg.AttributeProto.sint64_list)
  if (value_case() == kSint64List) {
    clear_has_value();
    auto* temp = _impl_.value_.sint64_list_;
    _impl_.value_.sint64_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeProto::unsafe_arena_set_allocated_sint64_list(::ChakraProtoMsg::Sint64List* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_sint64_list();
    _impl_.value_.sint64_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.AttributeProto.sint64_list)
}
inline ::ChakraProtoMsg::Sint64List* AttributeProto::_internal_mutable_sint64_list() {
  if (value_case() != kSint64List) {
    clear_value();
    set_has_sint64_list();
    _impl_.value_.sint64_list_ = CreateMaybeMessage<::ChakraProtoMsg::Sint64List>(GetArena());
  }
  return _impl_.value_.sint64_list_;
}
inline ::ChakraProtoMsg::Sint64List* AttributeProto::mutable_sint64_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ChakraProtoMsg::Sint64List* _msg = _internal_mutable_sint64_list();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.sint64_list)
  return _msg;
}

// fixed32 fixed32_val = 19;
inline bool AttributeProto::has_fixed32_val() const {
  return value_case() == kFixed32Val;
}
inline void AttributeProto::set_has_fixed32_val() {
  _impl_._oneof_case_[0] = kFixed32Val;
}
inline void AttributeProto::clear_fixed32_val() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kFixed32Val) {
    _impl_.value_.fixed32_val_ = 0u;
    clear_has_value();
  }
}
inline ::uint32_t AttributeProto::fixed32_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.fixed32_val)
  return _internal_fixed32_val();
}
inline void AttributeProto::set_fixed32_val(::uint32_t value) {
  _internal_set_fixed32_val(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.fixed32_val)
}
inline ::uint32_t AttributeProto::_internal_fixed32_val() const {
  if (value_case() == kFixed32Val) {
    return _impl_.value_.fixed32_val_;
  }
  return 0u;
}
inline void AttributeProto::_internal_set_fixed32_val(::uint32_t value) {
  if (value_case() != kFixed32Val) {
    clear_value();
    set_has_fixed32_val();
  }
  _impl_.value_.fixed32_val_ = value;
}

// .ChakraProtoMsg.Fixed32List fixed32_list = 20;
inline bool AttributeProto::has_fixed32_list() const {
  return value_case() == kFixed32List;
}
inline bool AttributeProto::_internal_has_fixed32_list() const {
  return value_case() == kFixed32List;
}
inline void AttributeProto::set_has_fixed32_list() {
  _impl_._oneof_case_[0] = kFixed32List;
}
inline void AttributeProto::clear_fixed32_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kFixed32List) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.fixed32_list_;
    }
    clear_has_value();
  }
}
inline ::ChakraProtoMsg::Fixed32List* AttributeProto::release_fixed32_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.fixed32_list)
  if (value_case() == kFixed32List) {
    clear_has_value();
    auto* temp = _impl_.value_.fixed32_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.fixed32_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChakraProtoMsg::Fixed32List& AttributeProto::_internal_fixed32_list() const {
  return value_case() == kFixed32List ? *_impl_.value_.fixed32_list_ : reinterpret_cast<::ChakraProtoMsg::Fixed32List&>(::ChakraProtoMsg::_Fixed32List_default_instance_);
}
inline const ::ChakraProtoMsg::Fixed32List& AttributeProto::fixed32_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.fixed32_list)
  return _internal_fixed32_list();
}
inline ::ChakraProtoMsg::Fixed32List* AttributeProto::unsafe_arena_release_fixed32_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ChakraProtoMsg.AttributeProto.fixed32_list)
  if (value_case() == kFixed32List) {
    clear_has_value();
    auto* temp = _impl_.value_.fixed32_list_;
    _impl_.value_.fixed32_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeProto::unsafe_arena_set_allocated_fixed32_list(::ChakraProtoMsg::Fixed32List* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_fixed32_list();
    _impl_.value_.fixed32_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.AttributeProto.fixed32_list)
}
inline ::ChakraProtoMsg::Fixed32List* AttributeProto::_internal_mutable_fixed32_list() {
  if (value_case() != kFixed32List) {
    clear_value();
    set_has_fixed32_list();
    _impl_.value_.fixed32_list_ = CreateMaybeMessage<::ChakraProtoMsg::Fixed32List>(GetArena());
  }
  return _impl_.value_.fixed32_list_;
}
inline ::ChakraProtoMsg::Fixed32List* AttributeProto::mutable_fixed32_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ChakraProtoMsg::Fixed32List* _msg = _internal_mutable_fixed32_list();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.fixed32_list)
  return _msg;
}

// fixed64 fixed64_val = 21;
inline bool AttributeProto::has_fixed64_val() const {
  return value_case() == kFixed64Val;
}
inline void AttributeProto::set_has_fixed64_val() {
  _impl_._oneof_case_[0] = kFixed64Val;
}
inline void AttributeProto::clear_fixed64_val() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kFixed64Val) {
    _impl_.value_.fixed64_val_ = ::uint64_t{0u};
    clear_has_value();
  }
}
inline ::uint64_t AttributeProto::fixed64_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.fixed64_val)
  return _internal_fixed64_val();
}
inline void AttributeProto::set_fixed64_val(::uint64_t value) {
  _internal_set_fixed64_val(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.fixed64_val)
}
inline ::uint64_t AttributeProto::_internal_fixed64_val() const {
  if (value_case() == kFixed64Val) {
    return _impl_.value_.fixed64_val_;
  }
  return ::uint64_t{0u};
}
inline void AttributeProto::_internal_set_fixed64_val(::uint64_t value) {
  if (value_case() != kFixed64Val) {
    clear_value();
    set_has_fixed64_val();
  }
  _impl_.value_.fixed64_val_ = value;
}

// .ChakraProtoMsg.Fixed64List fixed64_list = 22;
inline bool AttributeProto::has_fixed64_list() const {
  return value_case() == kFixed64List;
}
inline bool AttributeProto::_internal_has_fixed64_list() const {
  return value_case() == kFixed64List;
}
inline void AttributeProto::set_has_fixed64_list() {
  _impl_._oneof_case_[0] = kFixed64List;
}
inline void AttributeProto::clear_fixed64_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kFixed64List) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.fixed64_list_;
    }
    clear_has_value();
  }
}
inline ::ChakraProtoMsg::Fixed64List* AttributeProto::release_fixed64_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.fixed64_list)
  if (value_case() == kFixed64List) {
    clear_has_value();
    auto* temp = _impl_.value_.fixed64_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.fixed64_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChakraProtoMsg::Fixed64List& AttributeProto::_internal_fixed64_list() const {
  return value_case() == kFixed64List ? *_impl_.value_.fixed64_list_ : reinterpret_cast<::ChakraProtoMsg::Fixed64List&>(::ChakraProtoMsg::_Fixed64List_default_instance_);
}
inline const ::ChakraProtoMsg::Fixed64List& AttributeProto::fixed64_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.fixed64_list)
  return _internal_fixed64_list();
}
inline ::ChakraProtoMsg::Fixed64List* AttributeProto::unsafe_arena_release_fixed64_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ChakraProtoMsg.AttributeProto.fixed64_list)
  if (value_case() == kFixed64List) {
    clear_has_value();
    auto* temp = _impl_.value_.fixed64_list_;
    _impl_.value_.fixed64_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeProto::unsafe_arena_set_allocated_fixed64_list(::ChakraProtoMsg::Fixed64List* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_fixed64_list();
    _impl_.value_.fixed64_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.AttributeProto.fixed64_list)
}
inline ::ChakraProtoMsg::Fixed64List* AttributeProto::_internal_mutable_fixed64_list() {
  if (value_case() != kFixed64List) {
    clear_value();
    set_has_fixed64_list();
    _impl_.value_.fixed64_list_ = CreateMaybeMessage<::ChakraProtoMsg::Fixed64List>(GetArena());
  }
  return _impl_.value_.fixed64_list_;
}
inline ::ChakraProtoMsg::Fixed64List* AttributeProto::mutable_fixed64_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ChakraProtoMsg::Fixed64List* _msg = _internal_mutable_fixed64_list();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.fixed64_list)
  return _msg;
}

// sfixed32 sfixed32_val = 23;
inline bool AttributeProto::has_sfixed32_val() const {
  return value_case() == kSfixed32Val;
}
inline void AttributeProto::set_has_sfixed32_val() {
  _impl_._oneof_case_[0] = kSfixed32Val;
}
inline void AttributeProto::clear_sfixed32_val() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kSfixed32Val) {
    _impl_.value_.sfixed32_val_ = 0;
    clear_has_value();
  }
}
inline ::int32_t AttributeProto::sfixed32_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.sfixed32_val)
  return _internal_sfixed32_val();
}
inline void AttributeProto::set_sfixed32_val(::int32_t value) {
  _internal_set_sfixed32_val(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.sfixed32_val)
}
inline ::int32_t AttributeProto::_internal_sfixed32_val() const {
  if (value_case() == kSfixed32Val) {
    return _impl_.value_.sfixed32_val_;
  }
  return 0;
}
inline void AttributeProto::_internal_set_sfixed32_val(::int32_t value) {
  if (value_case() != kSfixed32Val) {
    clear_value();
    set_has_sfixed32_val();
  }
  _impl_.value_.sfixed32_val_ = value;
}

// .ChakraProtoMsg.Sfixed32List sfixed32_list = 24;
inline bool AttributeProto::has_sfixed32_list() const {
  return value_case() == kSfixed32List;
}
inline bool AttributeProto::_internal_has_sfixed32_list() const {
  return value_case() == kSfixed32List;
}
inline void AttributeProto::set_has_sfixed32_list() {
  _impl_._oneof_case_[0] = kSfixed32List;
}
inline void AttributeProto::clear_sfixed32_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kSfixed32List) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.sfixed32_list_;
    }
    clear_has_value();
  }
}
inline ::ChakraProtoMsg::Sfixed32List* AttributeProto::release_sfixed32_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.sfixed32_list)
  if (value_case() == kSfixed32List) {
    clear_has_value();
    auto* temp = _impl_.value_.sfixed32_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.sfixed32_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChakraProtoMsg::Sfixed32List& AttributeProto::_internal_sfixed32_list() const {
  return value_case() == kSfixed32List ? *_impl_.value_.sfixed32_list_ : reinterpret_cast<::ChakraProtoMsg::Sfixed32List&>(::ChakraProtoMsg::_Sfixed32List_default_instance_);
}
inline const ::ChakraProtoMsg::Sfixed32List& AttributeProto::sfixed32_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.sfixed32_list)
  return _internal_sfixed32_list();
}
inline ::ChakraProtoMsg::Sfixed32List* AttributeProto::unsafe_arena_release_sfixed32_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ChakraProtoMsg.AttributeProto.sfixed32_list)
  if (value_case() == kSfixed32List) {
    clear_has_value();
    auto* temp = _impl_.value_.sfixed32_list_;
    _impl_.value_.sfixed32_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeProto::unsafe_arena_set_allocated_sfixed32_list(::ChakraProtoMsg::Sfixed32List* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_sfixed32_list();
    _impl_.value_.sfixed32_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.AttributeProto.sfixed32_list)
}
inline ::ChakraProtoMsg::Sfixed32List* AttributeProto::_internal_mutable_sfixed32_list() {
  if (value_case() != kSfixed32List) {
    clear_value();
    set_has_sfixed32_list();
    _impl_.value_.sfixed32_list_ = CreateMaybeMessage<::ChakraProtoMsg::Sfixed32List>(GetArena());
  }
  return _impl_.value_.sfixed32_list_;
}
inline ::ChakraProtoMsg::Sfixed32List* AttributeProto::mutable_sfixed32_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ChakraProtoMsg::Sfixed32List* _msg = _internal_mutable_sfixed32_list();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.sfixed32_list)
  return _msg;
}

// sfixed64 sfixed64_val = 25;
inline bool AttributeProto::has_sfixed64_val() const {
  return value_case() == kSfixed64Val;
}
inline void AttributeProto::set_has_sfixed64_val() {
  _impl_._oneof_case_[0] = kSfixed64Val;
}
inline void AttributeProto::clear_sfixed64_val() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kSfixed64Val) {
    _impl_.value_.sfixed64_val_ = ::int64_t{0};
    clear_has_value();
  }
}
inline ::int64_t AttributeProto::sfixed64_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.sfixed64_val)
  return _internal_sfixed64_val();
}
inline void AttributeProto::set_sfixed64_val(::int64_t value) {
  _internal_set_sfixed64_val(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.sfixed64_val)
}
inline ::int64_t AttributeProto::_internal_sfixed64_val() const {
  if (value_case() == kSfixed64Val) {
    return _impl_.value_.sfixed64_val_;
  }
  return ::int64_t{0};
}
inline void AttributeProto::_internal_set_sfixed64_val(::int64_t value) {
  if (value_case() != kSfixed64Val) {
    clear_value();
    set_has_sfixed64_val();
  }
  _impl_.value_.sfixed64_val_ = value;
}

// .ChakraProtoMsg.Sfixed64List sfixed64_list = 26;
inline bool AttributeProto::has_sfixed64_list() const {
  return value_case() == kSfixed64List;
}
inline bool AttributeProto::_internal_has_sfixed64_list() const {
  return value_case() == kSfixed64List;
}
inline void AttributeProto::set_has_sfixed64_list() {
  _impl_._oneof_case_[0] = kSfixed64List;
}
inline void AttributeProto::clear_sfixed64_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kSfixed64List) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.sfixed64_list_;
    }
    clear_has_value();
  }
}
inline ::ChakraProtoMsg::Sfixed64List* AttributeProto::release_sfixed64_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.sfixed64_list)
  if (value_case() == kSfixed64List) {
    clear_has_value();
    auto* temp = _impl_.value_.sfixed64_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.sfixed64_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChakraProtoMsg::Sfixed64List& AttributeProto::_internal_sfixed64_list() const {
  return value_case() == kSfixed64List ? *_impl_.value_.sfixed64_list_ : reinterpret_cast<::ChakraProtoMsg::Sfixed64List&>(::ChakraProtoMsg::_Sfixed64List_default_instance_);
}
inline const ::ChakraProtoMsg::Sfixed64List& AttributeProto::sfixed64_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.sfixed64_list)
  return _internal_sfixed64_list();
}
inline ::ChakraProtoMsg::Sfixed64List* AttributeProto::unsafe_arena_release_sfixed64_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ChakraProtoMsg.AttributeProto.sfixed64_list)
  if (value_case() == kSfixed64List) {
    clear_has_value();
    auto* temp = _impl_.value_.sfixed64_list_;
    _impl_.value_.sfixed64_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeProto::unsafe_arena_set_allocated_sfixed64_list(::ChakraProtoMsg::Sfixed64List* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_sfixed64_list();
    _impl_.value_.sfixed64_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.AttributeProto.sfixed64_list)
}
inline ::ChakraProtoMsg::Sfixed64List* AttributeProto::_internal_mutable_sfixed64_list() {
  if (value_case() != kSfixed64List) {
    clear_value();
    set_has_sfixed64_list();
    _impl_.value_.sfixed64_list_ = CreateMaybeMessage<::ChakraProtoMsg::Sfixed64List>(GetArena());
  }
  return _impl_.value_.sfixed64_list_;
}
inline ::ChakraProtoMsg::Sfixed64List* AttributeProto::mutable_sfixed64_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ChakraProtoMsg::Sfixed64List* _msg = _internal_mutable_sfixed64_list();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.sfixed64_list)
  return _msg;
}

// bool bool_val = 27;
inline bool AttributeProto::has_bool_val() const {
  return value_case() == kBoolVal;
}
inline void AttributeProto::set_has_bool_val() {
  _impl_._oneof_case_[0] = kBoolVal;
}
inline void AttributeProto::clear_bool_val() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kBoolVal) {
    _impl_.value_.bool_val_ = false;
    clear_has_value();
  }
}
inline bool AttributeProto::bool_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.bool_val)
  return _internal_bool_val();
}
inline void AttributeProto::set_bool_val(bool value) {
  _internal_set_bool_val(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.bool_val)
}
inline bool AttributeProto::_internal_bool_val() const {
  if (value_case() == kBoolVal) {
    return _impl_.value_.bool_val_;
  }
  return false;
}
inline void AttributeProto::_internal_set_bool_val(bool value) {
  if (value_case() != kBoolVal) {
    clear_value();
    set_has_bool_val();
  }
  _impl_.value_.bool_val_ = value;
}

// .ChakraProtoMsg.BoolList bool_list = 28;
inline bool AttributeProto::has_bool_list() const {
  return value_case() == kBoolList;
}
inline bool AttributeProto::_internal_has_bool_list() const {
  return value_case() == kBoolList;
}
inline void AttributeProto::set_has_bool_list() {
  _impl_._oneof_case_[0] = kBoolList;
}
inline void AttributeProto::clear_bool_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kBoolList) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.bool_list_;
    }
    clear_has_value();
  }
}
inline ::ChakraProtoMsg::BoolList* AttributeProto::release_bool_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.bool_list)
  if (value_case() == kBoolList) {
    clear_has_value();
    auto* temp = _impl_.value_.bool_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.bool_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChakraProtoMsg::BoolList& AttributeProto::_internal_bool_list() const {
  return value_case() == kBoolList ? *_impl_.value_.bool_list_ : reinterpret_cast<::ChakraProtoMsg::BoolList&>(::ChakraProtoMsg::_BoolList_default_instance_);
}
inline const ::ChakraProtoMsg::BoolList& AttributeProto::bool_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.bool_list)
  return _internal_bool_list();
}
inline ::ChakraProtoMsg::BoolList* AttributeProto::unsafe_arena_release_bool_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ChakraProtoMsg.AttributeProto.bool_list)
  if (value_case() == kBoolList) {
    clear_has_value();
    auto* temp = _impl_.value_.bool_list_;
    _impl_.value_.bool_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeProto::unsafe_arena_set_allocated_bool_list(::ChakraProtoMsg::BoolList* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_bool_list();
    _impl_.value_.bool_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.AttributeProto.bool_list)
}
inline ::ChakraProtoMsg::BoolList* AttributeProto::_internal_mutable_bool_list() {
  if (value_case() != kBoolList) {
    clear_value();
    set_has_bool_list();
    _impl_.value_.bool_list_ = CreateMaybeMessage<::ChakraProtoMsg::BoolList>(GetArena());
  }
  return _impl_.value_.bool_list_;
}
inline ::ChakraProtoMsg::BoolList* AttributeProto::mutable_bool_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ChakraProtoMsg::BoolList* _msg = _internal_mutable_bool_list();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.bool_list)
  return _msg;
}

// string string_val = 29;
inline bool AttributeProto::has_string_val() const {
  return value_case() == kStringVal;
}
inline void AttributeProto::set_has_string_val() {
  _impl_._oneof_case_[0] = kStringVal;
}
inline void AttributeProto::clear_string_val() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kStringVal) {
    _impl_.value_.string_val_.Destroy();
    clear_has_value();
  }
}
inline const std::string& AttributeProto::string_val() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.string_val)
  return _internal_string_val();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AttributeProto::set_string_val(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() != kStringVal) {
    clear_value();

    set_has_string_val();
    _impl_.value_.string_val_.InitDefault();
  }
  _impl_.value_.string_val_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.string_val)
}
inline std::string* AttributeProto::mutable_string_val() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_string_val();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.string_val)
  return _s;
}
inline const std::string& AttributeProto::_internal_string_val() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (value_case() != kStringVal) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.value_.string_val_.Get();
}
inline void AttributeProto::_internal_set_string_val(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() != kStringVal) {
    clear_value();

    set_has_string_val();
    _impl_.value_.string_val_.InitDefault();
  }
  _impl_.value_.string_val_.Set(value, GetArena());
}
inline std::string* AttributeProto::_internal_mutable_string_val() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() != kStringVal) {
    clear_value();

    set_has_string_val();
    _impl_.value_.string_val_.InitDefault();
  }
  return _impl_.value_.string_val_.Mutable( GetArena());
}
inline std::string* AttributeProto::release_string_val() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.string_val)
  if (value_case() != kStringVal) {
    return nullptr;
  }
  clear_has_value();
  return _impl_.value_.string_val_.Release();
}
inline void AttributeProto::set_allocated_string_val(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_value()) {
    clear_value();
  }
  if (value != nullptr) {
    set_has_string_val();
    _impl_.value_.string_val_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.AttributeProto.string_val)
}

// .ChakraProtoMsg.StringList string_list = 30;
inline bool AttributeProto::has_string_list() const {
  return value_case() == kStringList;
}
inline bool AttributeProto::_internal_has_string_list() const {
  return value_case() == kStringList;
}
inline void AttributeProto::set_has_string_list() {
  _impl_._oneof_case_[0] = kStringList;
}
inline void AttributeProto::clear_string_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kStringList) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.string_list_;
    }
    clear_has_value();
  }
}
inline ::ChakraProtoMsg::StringList* AttributeProto::release_string_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.string_list)
  if (value_case() == kStringList) {
    clear_has_value();
    auto* temp = _impl_.value_.string_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.string_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChakraProtoMsg::StringList& AttributeProto::_internal_string_list() const {
  return value_case() == kStringList ? *_impl_.value_.string_list_ : reinterpret_cast<::ChakraProtoMsg::StringList&>(::ChakraProtoMsg::_StringList_default_instance_);
}
inline const ::ChakraProtoMsg::StringList& AttributeProto::string_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.string_list)
  return _internal_string_list();
}
inline ::ChakraProtoMsg::StringList* AttributeProto::unsafe_arena_release_string_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ChakraProtoMsg.AttributeProto.string_list)
  if (value_case() == kStringList) {
    clear_has_value();
    auto* temp = _impl_.value_.string_list_;
    _impl_.value_.string_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeProto::unsafe_arena_set_allocated_string_list(::ChakraProtoMsg::StringList* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_string_list();
    _impl_.value_.string_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.AttributeProto.string_list)
}
inline ::ChakraProtoMsg::StringList* AttributeProto::_internal_mutable_string_list() {
  if (value_case() != kStringList) {
    clear_value();
    set_has_string_list();
    _impl_.value_.string_list_ = CreateMaybeMessage<::ChakraProtoMsg::StringList>(GetArena());
  }
  return _impl_.value_.string_list_;
}
inline ::ChakraProtoMsg::StringList* AttributeProto::mutable_string_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ChakraProtoMsg::StringList* _msg = _internal_mutable_string_list();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.string_list)
  return _msg;
}

// bytes bytes_val = 31;
inline bool AttributeProto::has_bytes_val() const {
  return value_case() == kBytesVal;
}
inline void AttributeProto::set_has_bytes_val() {
  _impl_._oneof_case_[0] = kBytesVal;
}
inline void AttributeProto::clear_bytes_val() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kBytesVal) {
    _impl_.value_.bytes_val_.Destroy();
    clear_has_value();
  }
}
inline const std::string& AttributeProto::bytes_val() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.bytes_val)
  return _internal_bytes_val();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AttributeProto::set_bytes_val(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() != kBytesVal) {
    clear_value();

    set_has_bytes_val();
    _impl_.value_.bytes_val_.InitDefault();
  }
  _impl_.value_.bytes_val_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.bytes_val)
}
inline std::string* AttributeProto::mutable_bytes_val() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_bytes_val();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.bytes_val)
  return _s;
}
inline const std::string& AttributeProto::_internal_bytes_val() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (value_case() != kBytesVal) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.value_.bytes_val_.Get();
}
inline void AttributeProto::_internal_set_bytes_val(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() != kBytesVal) {
    clear_value();

    set_has_bytes_val();
    _impl_.value_.bytes_val_.InitDefault();
  }
  _impl_.value_.bytes_val_.Set(value, GetArena());
}
inline std::string* AttributeProto::_internal_mutable_bytes_val() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() != kBytesVal) {
    clear_value();

    set_has_bytes_val();
    _impl_.value_.bytes_val_.InitDefault();
  }
  return _impl_.value_.bytes_val_.Mutable( GetArena());
}
inline std::string* AttributeProto::release_bytes_val() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.bytes_val)
  if (value_case() != kBytesVal) {
    return nullptr;
  }
  clear_has_value();
  return _impl_.value_.bytes_val_.Release();
}
inline void AttributeProto::set_allocated_bytes_val(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_value()) {
    clear_value();
  }
  if (value != nullptr) {
    set_has_bytes_val();
    _impl_.value_.bytes_val_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.AttributeProto.bytes_val)
}

// .ChakraProtoMsg.BytesList bytes_list = 32;
inline bool AttributeProto::has_bytes_list() const {
  return value_case() == kBytesList;
}
inline bool AttributeProto::_internal_has_bytes_list() const {
  return value_case() == kBytesList;
}
inline void AttributeProto::set_has_bytes_list() {
  _impl_._oneof_case_[0] = kBytesList;
}
inline void AttributeProto::clear_bytes_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kBytesList) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.bytes_list_;
    }
    clear_has_value();
  }
}
inline ::ChakraProtoMsg::BytesList* AttributeProto::release_bytes_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.bytes_list)
  if (value_case() == kBytesList) {
    clear_has_value();
    auto* temp = _impl_.value_.bytes_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.bytes_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChakraProtoMsg::BytesList& AttributeProto::_internal_bytes_list() const {
  return value_case() == kBytesList ? *_impl_.value_.bytes_list_ : reinterpret_cast<::ChakraProtoMsg::BytesList&>(::ChakraProtoMsg::_BytesList_default_instance_);
}
inline const ::ChakraProtoMsg::BytesList& AttributeProto::bytes_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.bytes_list)
  return _internal_bytes_list();
}
inline ::ChakraProtoMsg::BytesList* AttributeProto::unsafe_arena_release_bytes_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ChakraProtoMsg.AttributeProto.bytes_list)
  if (value_case() == kBytesList) {
    clear_has_value();
    auto* temp = _impl_.value_.bytes_list_;
    _impl_.value_.bytes_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeProto::unsafe_arena_set_allocated_bytes_list(::ChakraProtoMsg::BytesList* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_bytes_list();
    _impl_.value_.bytes_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.AttributeProto.bytes_list)
}
inline ::ChakraProtoMsg::BytesList* AttributeProto::_internal_mutable_bytes_list() {
  if (value_case() != kBytesList) {
    clear_value();
    set_has_bytes_list();
    _impl_.value_.bytes_list_ = CreateMaybeMessage<::ChakraProtoMsg::BytesList>(GetArena());
  }
  return _impl_.value_.bytes_list_;
}
inline ::ChakraProtoMsg::BytesList* AttributeProto::mutable_bytes_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ChakraProtoMsg::BytesList* _msg = _internal_mutable_bytes_list();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.bytes_list)
  return _msg;
}

inline bool AttributeProto::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void AttributeProto::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline AttributeProto::ValueCase AttributeProto::value_case() const {
  return AttributeProto::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DoubleList

// repeated double values = 1;
inline int DoubleList::_internal_values_size() const {
  return _internal_values().size();
}
inline int DoubleList::values_size() const {
  return _internal_values_size();
}
inline void DoubleList::clear_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.Clear();
}
inline double DoubleList::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.DoubleList.values)
  return _internal_values().Get(index);
}
inline void DoubleList::set_values(int index, double value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.DoubleList.values)
}
inline void DoubleList::add_values(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.DoubleList.values)
}
inline const ::google::protobuf::RepeatedField<double>& DoubleList::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.DoubleList.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<double>* DoubleList::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.DoubleList.values)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<double>& DoubleList::_internal_values()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<double>* DoubleList::_internal_mutable_values() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// FloatList

// repeated float values = 1;
inline int FloatList::_internal_values_size() const {
  return _internal_values().size();
}
inline int FloatList::values_size() const {
  return _internal_values_size();
}
inline void FloatList::clear_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.Clear();
}
inline float FloatList::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.FloatList.values)
  return _internal_values().Get(index);
}
inline void FloatList::set_values(int index, float value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.FloatList.values)
}
inline void FloatList::add_values(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.FloatList.values)
}
inline const ::google::protobuf::RepeatedField<float>& FloatList::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.FloatList.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<float>* FloatList::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.FloatList.values)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<float>& FloatList::_internal_values()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<float>* FloatList::_internal_mutable_values() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// Int32List

// repeated int32 values = 1;
inline int Int32List::_internal_values_size() const {
  return _internal_values().size();
}
inline int Int32List::values_size() const {
  return _internal_values_size();
}
inline void Int32List::clear_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.Clear();
}
inline ::int32_t Int32List::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Int32List.values)
  return _internal_values().Get(index);
}
inline void Int32List::set_values(int index, ::int32_t value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Int32List.values)
}
inline void Int32List::add_values(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Int32List.values)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& Int32List::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Int32List.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<::int32_t>* Int32List::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Int32List.values)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& Int32List::_internal_values()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* Int32List::_internal_mutable_values() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// Int64List

// repeated int64 values = 1;
inline int Int64List::_internal_values_size() const {
  return _internal_values().size();
}
inline int Int64List::values_size() const {
  return _internal_values_size();
}
inline void Int64List::clear_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.Clear();
}
inline ::int64_t Int64List::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Int64List.values)
  return _internal_values().Get(index);
}
inline void Int64List::set_values(int index, ::int64_t value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Int64List.values)
}
inline void Int64List::add_values(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Int64List.values)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& Int64List::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Int64List.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<::int64_t>* Int64List::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Int64List.values)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<::int64_t>& Int64List::_internal_values()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* Int64List::_internal_mutable_values() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// Uint32List

// repeated uint32 values = 1;
inline int Uint32List::_internal_values_size() const {
  return _internal_values().size();
}
inline int Uint32List::values_size() const {
  return _internal_values_size();
}
inline void Uint32List::clear_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.Clear();
}
inline ::uint32_t Uint32List::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Uint32List.values)
  return _internal_values().Get(index);
}
inline void Uint32List::set_values(int index, ::uint32_t value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Uint32List.values)
}
inline void Uint32List::add_values(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Uint32List.values)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& Uint32List::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Uint32List.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* Uint32List::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Uint32List.values)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& Uint32List::_internal_values()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* Uint32List::_internal_mutable_values() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// Uint64List

// repeated uint64 values = 1;
inline int Uint64List::_internal_values_size() const {
  return _internal_values().size();
}
inline int Uint64List::values_size() const {
  return _internal_values_size();
}
inline void Uint64List::clear_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.Clear();
}
inline ::uint64_t Uint64List::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Uint64List.values)
  return _internal_values().Get(index);
}
inline void Uint64List::set_values(int index, ::uint64_t value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Uint64List.values)
}
inline void Uint64List::add_values(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Uint64List.values)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& Uint64List::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Uint64List.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* Uint64List::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Uint64List.values)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& Uint64List::_internal_values()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* Uint64List::_internal_mutable_values() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// Sint32List

// repeated sint32 values = 1;
inline int Sint32List::_internal_values_size() const {
  return _internal_values().size();
}
inline int Sint32List::values_size() const {
  return _internal_values_size();
}
inline void Sint32List::clear_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.Clear();
}
inline ::int32_t Sint32List::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Sint32List.values)
  return _internal_values().Get(index);
}
inline void Sint32List::set_values(int index, ::int32_t value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Sint32List.values)
}
inline void Sint32List::add_values(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Sint32List.values)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& Sint32List::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Sint32List.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<::int32_t>* Sint32List::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Sint32List.values)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& Sint32List::_internal_values()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* Sint32List::_internal_mutable_values() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// Sint64List

// repeated sint64 values = 1;
inline int Sint64List::_internal_values_size() const {
  return _internal_values().size();
}
inline int Sint64List::values_size() const {
  return _internal_values_size();
}
inline void Sint64List::clear_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.Clear();
}
inline ::int64_t Sint64List::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Sint64List.values)
  return _internal_values().Get(index);
}
inline void Sint64List::set_values(int index, ::int64_t value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Sint64List.values)
}
inline void Sint64List::add_values(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Sint64List.values)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& Sint64List::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Sint64List.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<::int64_t>* Sint64List::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Sint64List.values)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<::int64_t>& Sint64List::_internal_values()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* Sint64List::_internal_mutable_values() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// Fixed32List

// repeated fixed32 values = 1;
inline int Fixed32List::_internal_values_size() const {
  return _internal_values().size();
}
inline int Fixed32List::values_size() const {
  return _internal_values_size();
}
inline void Fixed32List::clear_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.Clear();
}
inline ::uint32_t Fixed32List::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Fixed32List.values)
  return _internal_values().Get(index);
}
inline void Fixed32List::set_values(int index, ::uint32_t value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Fixed32List.values)
}
inline void Fixed32List::add_values(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Fixed32List.values)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& Fixed32List::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Fixed32List.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* Fixed32List::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Fixed32List.values)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& Fixed32List::_internal_values()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* Fixed32List::_internal_mutable_values() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// Fixed64List

// repeated fixed64 values = 1;
inline int Fixed64List::_internal_values_size() const {
  return _internal_values().size();
}
inline int Fixed64List::values_size() const {
  return _internal_values_size();
}
inline void Fixed64List::clear_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.Clear();
}
inline ::uint64_t Fixed64List::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Fixed64List.values)
  return _internal_values().Get(index);
}
inline void Fixed64List::set_values(int index, ::uint64_t value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Fixed64List.values)
}
inline void Fixed64List::add_values(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Fixed64List.values)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& Fixed64List::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Fixed64List.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* Fixed64List::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Fixed64List.values)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& Fixed64List::_internal_values()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* Fixed64List::_internal_mutable_values() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// Sfixed32List

// repeated sfixed32 values = 1;
inline int Sfixed32List::_internal_values_size() const {
  return _internal_values().size();
}
inline int Sfixed32List::values_size() const {
  return _internal_values_size();
}
inline void Sfixed32List::clear_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.Clear();
}
inline ::int32_t Sfixed32List::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Sfixed32List.values)
  return _internal_values().Get(index);
}
inline void Sfixed32List::set_values(int index, ::int32_t value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Sfixed32List.values)
}
inline void Sfixed32List::add_values(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Sfixed32List.values)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& Sfixed32List::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Sfixed32List.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<::int32_t>* Sfixed32List::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Sfixed32List.values)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& Sfixed32List::_internal_values()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* Sfixed32List::_internal_mutable_values() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// Sfixed64List

// repeated sfixed64 values = 1;
inline int Sfixed64List::_internal_values_size() const {
  return _internal_values().size();
}
inline int Sfixed64List::values_size() const {
  return _internal_values_size();
}
inline void Sfixed64List::clear_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.Clear();
}
inline ::int64_t Sfixed64List::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Sfixed64List.values)
  return _internal_values().Get(index);
}
inline void Sfixed64List::set_values(int index, ::int64_t value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Sfixed64List.values)
}
inline void Sfixed64List::add_values(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Sfixed64List.values)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& Sfixed64List::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Sfixed64List.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<::int64_t>* Sfixed64List::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Sfixed64List.values)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<::int64_t>& Sfixed64List::_internal_values()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* Sfixed64List::_internal_mutable_values() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// BoolList

// repeated bool values = 1;
inline int BoolList::_internal_values_size() const {
  return _internal_values().size();
}
inline int BoolList::values_size() const {
  return _internal_values_size();
}
inline void BoolList::clear_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.Clear();
}
inline bool BoolList::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.BoolList.values)
  return _internal_values().Get(index);
}
inline void BoolList::set_values(int index, bool value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.BoolList.values)
}
inline void BoolList::add_values(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.BoolList.values)
}
inline const ::google::protobuf::RepeatedField<bool>& BoolList::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.BoolList.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<bool>* BoolList::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.BoolList.values)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<bool>& BoolList::_internal_values()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<bool>* BoolList::_internal_mutable_values() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// StringList

// repeated string values = 1;
inline int StringList::_internal_values_size() const {
  return _internal_values().size();
}
inline int StringList::values_size() const {
  return _internal_values_size();
}
inline void StringList::clear_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.Clear();
}
inline std::string* StringList::add_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_values()->Add();
  // @@protoc_insertion_point(field_add_mutable:ChakraProtoMsg.StringList.values)
  return _s;
}
inline const std::string& StringList::values(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.StringList.values)
  return _internal_values().Get(index);
}
inline std::string* StringList::mutable_values(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.StringList.values)
  return _internal_mutable_values()->Mutable(index);
}
inline void StringList::set_values(int index, const std::string& value) {
  _internal_mutable_values()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.StringList.values)
}
inline void StringList::set_values(int index, std::string&& value) {
  _internal_mutable_values()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.StringList.values)
}
inline void StringList::set_values(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_values()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ChakraProtoMsg.StringList.values)
}
inline void StringList::set_values(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_values()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ChakraProtoMsg.StringList.values)
}
inline void StringList::set_values(int index, absl::string_view value) {
  _internal_mutable_values()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:ChakraProtoMsg.StringList.values)
}
inline void StringList::add_values(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.StringList.values)
}
inline void StringList::add_values(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.StringList.values)
}
inline void StringList::add_values(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ChakraProtoMsg.StringList.values)
}
inline void StringList::add_values(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ChakraProtoMsg.StringList.values)
}
inline void StringList::add_values(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:ChakraProtoMsg.StringList.values)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
StringList::values() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.StringList.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
StringList::mutable_values() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.StringList.values)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
StringList::_internal_values() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
StringList::_internal_mutable_values() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// BytesList

// repeated bytes values = 1;
inline int BytesList::_internal_values_size() const {
  return _internal_values().size();
}
inline int BytesList::values_size() const {
  return _internal_values_size();
}
inline void BytesList::clear_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.Clear();
}
inline std::string* BytesList::add_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_values()->Add();
  // @@protoc_insertion_point(field_add_mutable:ChakraProtoMsg.BytesList.values)
  return _s;
}
inline const std::string& BytesList::values(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.BytesList.values)
  return _internal_values().Get(index);
}
inline std::string* BytesList::mutable_values(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.BytesList.values)
  return _internal_mutable_values()->Mutable(index);
}
inline void BytesList::set_values(int index, const std::string& value) {
  _internal_mutable_values()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.BytesList.values)
}
inline void BytesList::set_values(int index, std::string&& value) {
  _internal_mutable_values()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.BytesList.values)
}
inline void BytesList::set_values(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_values()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ChakraProtoMsg.BytesList.values)
}
inline void BytesList::set_values(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_values()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ChakraProtoMsg.BytesList.values)
}
inline void BytesList::set_values(int index, absl::string_view value) {
  _internal_mutable_values()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:ChakraProtoMsg.BytesList.values)
}
inline void BytesList::add_values(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.BytesList.values)
}
inline void BytesList::add_values(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.BytesList.values)
}
inline void BytesList::add_values(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ChakraProtoMsg.BytesList.values)
}
inline void BytesList::add_values(const void* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ChakraProtoMsg.BytesList.values)
}
inline void BytesList::add_values(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:ChakraProtoMsg.BytesList.values)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BytesList::values() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.BytesList.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
BytesList::mutable_values() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.BytesList.values)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BytesList::_internal_values() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
BytesList::_internal_mutable_values() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// GlobalMetadata

// string version = 1;
inline void GlobalMetadata::clear_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GlobalMetadata::version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.GlobalMetadata.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GlobalMetadata::set_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.GlobalMetadata.version)
}
inline std::string* GlobalMetadata::mutable_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.GlobalMetadata.version)
  return _s;
}
inline const std::string& GlobalMetadata::_internal_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.version_.Get();
}
inline void GlobalMetadata::_internal_set_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_.Set(value, GetArena());
}
inline std::string* GlobalMetadata::_internal_mutable_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.version_.Mutable( GetArena());
}
inline std::string* GlobalMetadata::release_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.GlobalMetadata.version)
  return _impl_.version_.Release();
}
inline void GlobalMetadata::set_allocated_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.GlobalMetadata.version)
}

// repeated .ChakraProtoMsg.AttributeProto attr = 2;
inline int GlobalMetadata::_internal_attr_size() const {
  return _internal_attr().size();
}
inline int GlobalMetadata::attr_size() const {
  return _internal_attr_size();
}
inline void GlobalMetadata::clear_attr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.attr_.Clear();
}
inline ::ChakraProtoMsg::AttributeProto* GlobalMetadata::mutable_attr(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.GlobalMetadata.attr)
  return _internal_mutable_attr()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::ChakraProtoMsg::AttributeProto>* GlobalMetadata::mutable_attr()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.GlobalMetadata.attr)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_attr();
}
inline const ::ChakraProtoMsg::AttributeProto& GlobalMetadata::attr(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.GlobalMetadata.attr)
  return _internal_attr().Get(index);
}
inline ::ChakraProtoMsg::AttributeProto* GlobalMetadata::add_attr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ChakraProtoMsg::AttributeProto* _add = _internal_mutable_attr()->Add();
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.GlobalMetadata.attr)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::ChakraProtoMsg::AttributeProto>& GlobalMetadata::attr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.GlobalMetadata.attr)
  return _internal_attr();
}
inline const ::google::protobuf::RepeatedPtrField<::ChakraProtoMsg::AttributeProto>&
GlobalMetadata::_internal_attr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attr_;
}
inline ::google::protobuf::RepeatedPtrField<::ChakraProtoMsg::AttributeProto>*
GlobalMetadata::_internal_mutable_attr() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.attr_;
}

// -------------------------------------------------------------------

// Node

// uint64 id = 1;
inline void Node::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t Node::id() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Node.id)
  return _internal_id();
}
inline void Node::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Node.id)
}
inline ::uint64_t Node::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void Node::_internal_set_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string name = 2;
inline void Node::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Node::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Node.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Node::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Node.name)
}
inline std::string* Node::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.Node.name)
  return _s;
}
inline const std::string& Node::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Node::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Node::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Node::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.Node.name)
  return _impl_.name_.Release();
}
inline void Node::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.Node.name)
}

// .ChakraProtoMsg.NodeType type = 3;
inline void Node::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::ChakraProtoMsg::NodeType Node::type() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Node.type)
  return _internal_type();
}
inline void Node::set_type(::ChakraProtoMsg::NodeType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Node.type)
}
inline ::ChakraProtoMsg::NodeType Node::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ChakraProtoMsg::NodeType>(_impl_.type_);
}
inline void Node::_internal_set_type(::ChakraProtoMsg::NodeType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// repeated uint64 ctrl_deps = 4;
inline int Node::_internal_ctrl_deps_size() const {
  return _internal_ctrl_deps().size();
}
inline int Node::ctrl_deps_size() const {
  return _internal_ctrl_deps_size();
}
inline void Node::clear_ctrl_deps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ctrl_deps_.Clear();
}
inline ::uint64_t Node::ctrl_deps(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Node.ctrl_deps)
  return _internal_ctrl_deps().Get(index);
}
inline void Node::set_ctrl_deps(int index, ::uint64_t value) {
  _internal_mutable_ctrl_deps()->Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Node.ctrl_deps)
}
inline void Node::add_ctrl_deps(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ctrl_deps()->Add(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Node.ctrl_deps)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& Node::ctrl_deps() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Node.ctrl_deps)
  return _internal_ctrl_deps();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* Node::mutable_ctrl_deps()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Node.ctrl_deps)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_ctrl_deps();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& Node::_internal_ctrl_deps()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ctrl_deps_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* Node::_internal_mutable_ctrl_deps() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.ctrl_deps_;
}

// repeated uint64 data_deps = 5;
inline int Node::_internal_data_deps_size() const {
  return _internal_data_deps().size();
}
inline int Node::data_deps_size() const {
  return _internal_data_deps_size();
}
inline void Node::clear_data_deps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_deps_.Clear();
}
inline ::uint64_t Node::data_deps(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Node.data_deps)
  return _internal_data_deps().Get(index);
}
inline void Node::set_data_deps(int index, ::uint64_t value) {
  _internal_mutable_data_deps()->Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Node.data_deps)
}
inline void Node::add_data_deps(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_data_deps()->Add(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Node.data_deps)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& Node::data_deps() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Node.data_deps)
  return _internal_data_deps();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* Node::mutable_data_deps()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Node.data_deps)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_data_deps();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& Node::_internal_data_deps()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_deps_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* Node::_internal_mutable_data_deps() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.data_deps_;
}

// uint64 start_time_micros = 6;
inline void Node::clear_start_time_micros() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.start_time_micros_ = ::uint64_t{0u};
}
inline ::uint64_t Node::start_time_micros() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Node.start_time_micros)
  return _internal_start_time_micros();
}
inline void Node::set_start_time_micros(::uint64_t value) {
  _internal_set_start_time_micros(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Node.start_time_micros)
}
inline ::uint64_t Node::_internal_start_time_micros() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_time_micros_;
}
inline void Node::_internal_set_start_time_micros(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.start_time_micros_ = value;
}

// uint64 duration_micros = 7;
inline void Node::clear_duration_micros() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.duration_micros_ = ::uint64_t{0u};
}
inline ::uint64_t Node::duration_micros() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Node.duration_micros)
  return _internal_duration_micros();
}
inline void Node::set_duration_micros(::uint64_t value) {
  _internal_set_duration_micros(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Node.duration_micros)
}
inline ::uint64_t Node::_internal_duration_micros() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.duration_micros_;
}
inline void Node::_internal_set_duration_micros(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.duration_micros_ = value;
}

// .ChakraProtoMsg.IOInfo inputs = 8;
inline bool Node::has_inputs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.inputs_ != nullptr);
  return value;
}
inline void Node::clear_inputs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.inputs_ != nullptr) _impl_.inputs_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ChakraProtoMsg::IOInfo& Node::_internal_inputs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ChakraProtoMsg::IOInfo* p = _impl_.inputs_;
  return p != nullptr ? *p : reinterpret_cast<const ::ChakraProtoMsg::IOInfo&>(::ChakraProtoMsg::_IOInfo_default_instance_);
}
inline const ::ChakraProtoMsg::IOInfo& Node::inputs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Node.inputs)
  return _internal_inputs();
}
inline void Node::unsafe_arena_set_allocated_inputs(::ChakraProtoMsg::IOInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.inputs_);
  }
  _impl_.inputs_ = reinterpret_cast<::ChakraProtoMsg::IOInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.Node.inputs)
}
inline ::ChakraProtoMsg::IOInfo* Node::release_inputs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ChakraProtoMsg::IOInfo* released = _impl_.inputs_;
  _impl_.inputs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ChakraProtoMsg::IOInfo* Node::unsafe_arena_release_inputs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.Node.inputs)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ChakraProtoMsg::IOInfo* temp = _impl_.inputs_;
  _impl_.inputs_ = nullptr;
  return temp;
}
inline ::ChakraProtoMsg::IOInfo* Node::_internal_mutable_inputs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.inputs_ == nullptr) {
    auto* p = CreateMaybeMessage<::ChakraProtoMsg::IOInfo>(GetArena());
    _impl_.inputs_ = reinterpret_cast<::ChakraProtoMsg::IOInfo*>(p);
  }
  return _impl_.inputs_;
}
inline ::ChakraProtoMsg::IOInfo* Node::mutable_inputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ChakraProtoMsg::IOInfo* _msg = _internal_mutable_inputs();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.Node.inputs)
  return _msg;
}
inline void Node::set_allocated_inputs(::ChakraProtoMsg::IOInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ChakraProtoMsg::IOInfo*>(_impl_.inputs_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::ChakraProtoMsg::IOInfo*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.inputs_ = reinterpret_cast<::ChakraProtoMsg::IOInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.Node.inputs)
}

// .ChakraProtoMsg.IOInfo outputs = 9;
inline bool Node::has_outputs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.outputs_ != nullptr);
  return value;
}
inline void Node::clear_outputs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.outputs_ != nullptr) _impl_.outputs_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::ChakraProtoMsg::IOInfo& Node::_internal_outputs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ChakraProtoMsg::IOInfo* p = _impl_.outputs_;
  return p != nullptr ? *p : reinterpret_cast<const ::ChakraProtoMsg::IOInfo&>(::ChakraProtoMsg::_IOInfo_default_instance_);
}
inline const ::ChakraProtoMsg::IOInfo& Node::outputs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Node.outputs)
  return _internal_outputs();
}
inline void Node::unsafe_arena_set_allocated_outputs(::ChakraProtoMsg::IOInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.outputs_);
  }
  _impl_.outputs_ = reinterpret_cast<::ChakraProtoMsg::IOInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.Node.outputs)
}
inline ::ChakraProtoMsg::IOInfo* Node::release_outputs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ChakraProtoMsg::IOInfo* released = _impl_.outputs_;
  _impl_.outputs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ChakraProtoMsg::IOInfo* Node::unsafe_arena_release_outputs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.Node.outputs)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::ChakraProtoMsg::IOInfo* temp = _impl_.outputs_;
  _impl_.outputs_ = nullptr;
  return temp;
}
inline ::ChakraProtoMsg::IOInfo* Node::_internal_mutable_outputs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.outputs_ == nullptr) {
    auto* p = CreateMaybeMessage<::ChakraProtoMsg::IOInfo>(GetArena());
    _impl_.outputs_ = reinterpret_cast<::ChakraProtoMsg::IOInfo*>(p);
  }
  return _impl_.outputs_;
}
inline ::ChakraProtoMsg::IOInfo* Node::mutable_outputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ChakraProtoMsg::IOInfo* _msg = _internal_mutable_outputs();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.Node.outputs)
  return _msg;
}
inline void Node::set_allocated_outputs(::ChakraProtoMsg::IOInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ChakraProtoMsg::IOInfo*>(_impl_.outputs_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::ChakraProtoMsg::IOInfo*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.outputs_ = reinterpret_cast<::ChakraProtoMsg::IOInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.Node.outputs)
}

// repeated .ChakraProtoMsg.AttributeProto attr = 10;
inline int Node::_internal_attr_size() const {
  return _internal_attr().size();
}
inline int Node::attr_size() const {
  return _internal_attr_size();
}
inline void Node::clear_attr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.attr_.Clear();
}
inline ::ChakraProtoMsg::AttributeProto* Node::mutable_attr(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.Node.attr)
  return _internal_mutable_attr()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::ChakraProtoMsg::AttributeProto>* Node::mutable_attr()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Node.attr)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_attr();
}
inline const ::ChakraProtoMsg::AttributeProto& Node::attr(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Node.attr)
  return _internal_attr().Get(index);
}
inline ::ChakraProtoMsg::AttributeProto* Node::add_attr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ChakraProtoMsg::AttributeProto* _add = _internal_mutable_attr()->Add();
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Node.attr)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::ChakraProtoMsg::AttributeProto>& Node::attr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Node.attr)
  return _internal_attr();
}
inline const ::google::protobuf::RepeatedPtrField<::ChakraProtoMsg::AttributeProto>&
Node::_internal_attr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attr_;
}
inline ::google::protobuf::RepeatedPtrField<::ChakraProtoMsg::AttributeProto>*
Node::_internal_mutable_attr() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.attr_;
}

// -------------------------------------------------------------------

// IOInfo

// string values = 1;
inline void IOInfo::clear_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.ClearToEmpty();
}
inline const std::string& IOInfo::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.IOInfo.values)
  return _internal_values();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IOInfo::set_values(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.values_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.IOInfo.values)
}
inline std::string* IOInfo::mutable_values() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_values();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.IOInfo.values)
  return _s;
}
inline const std::string& IOInfo::_internal_values() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_.Get();
}
inline void IOInfo::_internal_set_values(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.values_.Set(value, GetArena());
}
inline std::string* IOInfo::_internal_mutable_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.values_.Mutable( GetArena());
}
inline std::string* IOInfo::release_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.IOInfo.values)
  return _impl_.values_.Release();
}
inline void IOInfo::set_allocated_values(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.values_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.values_.IsDefault()) {
          _impl_.values_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.IOInfo.values)
}

// string shapes = 2;
inline void IOInfo::clear_shapes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shapes_.ClearToEmpty();
}
inline const std::string& IOInfo::shapes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.IOInfo.shapes)
  return _internal_shapes();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IOInfo::set_shapes(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.shapes_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.IOInfo.shapes)
}
inline std::string* IOInfo::mutable_shapes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_shapes();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.IOInfo.shapes)
  return _s;
}
inline const std::string& IOInfo::_internal_shapes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.shapes_.Get();
}
inline void IOInfo::_internal_set_shapes(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.shapes_.Set(value, GetArena());
}
inline std::string* IOInfo::_internal_mutable_shapes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.shapes_.Mutable( GetArena());
}
inline std::string* IOInfo::release_shapes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.IOInfo.shapes)
  return _impl_.shapes_.Release();
}
inline void IOInfo::set_allocated_shapes(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shapes_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.shapes_.IsDefault()) {
          _impl_.shapes_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.IOInfo.shapes)
}

// string types = 3;
inline void IOInfo::clear_types() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.types_.ClearToEmpty();
}
inline const std::string& IOInfo::types() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.IOInfo.types)
  return _internal_types();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IOInfo::set_types(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.types_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.IOInfo.types)
}
inline std::string* IOInfo::mutable_types() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_types();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.IOInfo.types)
  return _s;
}
inline const std::string& IOInfo::_internal_types() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.types_.Get();
}
inline void IOInfo::_internal_set_types(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.types_.Set(value, GetArena());
}
inline std::string* IOInfo::_internal_mutable_types() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.types_.Mutable( GetArena());
}
inline std::string* IOInfo::release_types() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.IOInfo.types)
  return _impl_.types_.Release();
}
inline void IOInfo::set_allocated_types(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.types_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.types_.IsDefault()) {
          _impl_.types_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.IOInfo.types)
}

// -------------------------------------------------------------------

// Tensor

// uint64 tensor_id = 1;
inline void Tensor::clear_tensor_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tensor_id_ = ::uint64_t{0u};
}
inline ::uint64_t Tensor::tensor_id() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Tensor.tensor_id)
  return _internal_tensor_id();
}
inline void Tensor::set_tensor_id(::uint64_t value) {
  _internal_set_tensor_id(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Tensor.tensor_id)
}
inline ::uint64_t Tensor::_internal_tensor_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tensor_id_;
}
inline void Tensor::_internal_set_tensor_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tensor_id_ = value;
}

// uint64 storage_id = 2;
inline void Tensor::clear_storage_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.storage_id_ = ::uint64_t{0u};
}
inline ::uint64_t Tensor::storage_id() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Tensor.storage_id)
  return _internal_storage_id();
}
inline void Tensor::set_storage_id(::uint64_t value) {
  _internal_set_storage_id(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Tensor.storage_id)
}
inline ::uint64_t Tensor::_internal_storage_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.storage_id_;
}
inline void Tensor::_internal_set_storage_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.storage_id_ = value;
}

// uint64 offset = 3;
inline void Tensor::clear_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.offset_ = ::uint64_t{0u};
}
inline ::uint64_t Tensor::offset() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Tensor.offset)
  return _internal_offset();
}
inline void Tensor::set_offset(::uint64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Tensor.offset)
}
inline ::uint64_t Tensor::_internal_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.offset_;
}
inline void Tensor::_internal_set_offset(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.offset_ = value;
}

// uint64 num_elem = 4;
inline void Tensor::clear_num_elem() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_elem_ = ::uint64_t{0u};
}
inline ::uint64_t Tensor::num_elem() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Tensor.num_elem)
  return _internal_num_elem();
}
inline void Tensor::set_num_elem(::uint64_t value) {
  _internal_set_num_elem(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Tensor.num_elem)
}
inline ::uint64_t Tensor::_internal_num_elem() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_elem_;
}
inline void Tensor::_internal_set_num_elem(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.num_elem_ = value;
}

// uint64 elem_bytes = 5;
inline void Tensor::clear_elem_bytes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.elem_bytes_ = ::uint64_t{0u};
}
inline ::uint64_t Tensor::elem_bytes() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Tensor.elem_bytes)
  return _internal_elem_bytes();
}
inline void Tensor::set_elem_bytes(::uint64_t value) {
  _internal_set_elem_bytes(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Tensor.elem_bytes)
}
inline ::uint64_t Tensor::_internal_elem_bytes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.elem_bytes_;
}
inline void Tensor::_internal_set_elem_bytes(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.elem_bytes_ = value;
}

// string device = 6;
inline void Tensor::clear_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.ClearToEmpty();
}
inline const std::string& Tensor::device() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Tensor.device)
  return _internal_device();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Tensor::set_device(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Tensor.device)
}
inline std::string* Tensor::mutable_device() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.Tensor.device)
  return _s;
}
inline const std::string& Tensor::_internal_device() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_.Get();
}
inline void Tensor::_internal_set_device(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_.Set(value, GetArena());
}
inline std::string* Tensor::_internal_mutable_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.device_.Mutable( GetArena());
}
inline std::string* Tensor::release_device() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.Tensor.device)
  return _impl_.device_.Release();
}
inline void Tensor::set_allocated_device(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_.IsDefault()) {
          _impl_.device_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.Tensor.device)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace ChakraProtoMsg


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::ChakraProtoMsg::NodeType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ChakraProtoMsg::NodeType>() {
  return ::ChakraProtoMsg::NodeType_descriptor();
}
template <>
struct is_proto_enum<::ChakraProtoMsg::CollectiveCommType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ChakraProtoMsg::CollectiveCommType>() {
  return ::ChakraProtoMsg::CollectiveCommType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_et_5fdef_2eproto_2epb_2eh
